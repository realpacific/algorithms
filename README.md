
# algorithms :robot:

Collection of Data Structures and Algorithms solutions

### Table of Contents

| Filename | Description |
|  --- | --- |
|  [TowerOfHanoi](src/dynamic/TowerOfHanoi.java) <br><sub>Java &#8226; dynamic</sub> |  |
|  [PaintFill](src/dynamic/PaintFill.java) <br><sub>Java &#8226; dynamic</sub> | Implement the"paint fill" function that one might see on many image editing programs. That is, given a screen (represented by a two-dimensional array of colors), a point, and a new color, fill in the surrounding area until the color changes from the original color |
|  [BooleanEvaluation](src/dynamic/BooleanEvaluation.java) <br><sub>Java &#8226; dynamic</sub> |  |
|  [PermutationWithDuplicates](src/dynamic/PermutationWithDuplicates.java) <br><sub>Java &#8226; dynamic</sub> |  |
|  [PermutationWithoutDuplicates](src/dynamic/PermutationWithoutDuplicates.java) <br><sub>Java &#8226; dynamic</sub> |  |
|  [EightQueens](src/dynamic/EightQueens.java) <br><sub>Java &#8226; dynamic</sub> |  |
|  [Parens](src/dynamic/Parens.java) <br><sub>Java &#8226; dynamic</sub> | Implement an algorithm to print all valid (i.e., properly opened and closed) combinations of n pairs of parentheses |
|  [Coins](src/dynamic/Coins.java) <br><sub>Java &#8226; dynamic</sub> |  |
|  [RecursiveMultiply](src/dynamic/RecursiveMultiply.java) <br><sub>Java &#8226; dynamic</sub> | Multiply without using *. |
|  [EditDistance](src/algorithmdesignmanualbook/dynamic/EditDistance.kt) <br><sub>Kotlin &#8226; dynamic</sub> |  |
|  [MinDifferenceBetweenSubsets](src/algorithmdesignmanualbook/dynamic/MinDifferenceBetweenSubsets.kt) <br><sub>Kotlin &#8226; dynamic</sub> |  |
|  [SortedMerge](src/sortingandsearch/SortedMerge.java) <br><sub>Java &#8226; sortingandsearch</sub> | You are given two sorted arrays, A and B, where A has a large enough buffer at the end to hold B. Write a method to merge B into A in sorted order. |
|  [SortedSearchNoSize](src/sortingandsearch/SortedSearchNoSize.java) <br><sub>Java &#8226; sortingandsearch</sub> | You are given an array-like data structure Listy which lacks a size method. It does, however, have an elementAt(i) method that returns the element at index i in 0(1) time. If i is beyond the bounds of the data structure, it returns -1. (For this reason, the data structure only supports positive integers.) Given a Listy which contains sorted, positive integers, fnd the index at which an element x occurs. If x occurs multiple times, you may return any index. |
|  [SparseSearch](src/sortingandsearch/SparseSearch.java) <br><sub>Java &#8226; sortingandsearch</sub> | Given a sorted array of strings that is interspersed with empty strings, write a method to fnd the location of a given string. |
|  [SortedMatrixSearch](src/sortingandsearch/SortedMatrixSearch.java) <br><sub>Java &#8226; sortingandsearch</sub> |  |
|  [RankFromStream](src/sortingandsearch/RankFromStream.java) <br><sub>Java &#8226; sortingandsearch</sub> | Imagine you are reading in a stream of integers. Periodically, you wish to be able to look up the rank of a number x (the number of values less than or equal to x). Implement the data structures and algorithms to support these operations. That is, implement the method track(int x), which is called when each number is generated, and the method getRankOfNumber(int x), which returns the number of values less than or equal to x (not including x itself). |
|  [GroupAnagrams](src/sortingandsearch/GroupAnagrams.java) <br><sub>Java &#8226; sortingandsearch</sub> | Write a method to sort an array ot strings so that all tne anagrams are next to each other. |
|  [PeaksAndValley](src/sortingandsearch/PeaksAndValley.java) <br><sub>Java &#8226; sortingandsearch</sub> |  |
|  [Shuffle](src/hard/Shuffle.java) <br><sub>Java &#8226; hard</sub> |  |
|  [AddWithoutPlus](src/hard/AddWithoutPlus.java) <br><sub>Java &#8226; hard</sub> |  |
|  [RandomSet](src/hard/RandomSet.java) <br><sub>Java &#8226; hard</sub> |  |
|  [count_of_2s](python/hard/count_of_2s.py) <br><sub>Python &#8226; hard</sub> | Find the number of 2s in between 0 and n <br>:param number: the max value (inclusive) <br>:return: Number of 2s |
|  [baby_names](python/hard/baby_names.py) <br><sub>Python &#8226; hard</sub> |  |
|  [letters_and_numbers](python/hard/letters_and_numbers.py) <br><sub>Python &#8226; hard</sub> |  |
|  [PowerOf2](src/bigo/PowerOf2.java) <br><sub>Java &#8226; bigo</sub> |  |
|  [PermutationCount](src/bigo/PermutationCount.java) <br><sub>Java &#8226; bigo</sub> |  |
|  [BinaryToString](src/bits/BinaryToString.java) <br><sub>Java &#8226; bits</sub> | Given a real number between 0 & 1 (eg. 0.72) that is passed in as double, print the binary representation. If # cannot be expressed in binary with at most 32 bits, then throw ERROR. |
|  [FlipBitToWin](src/bits/FlipBitToWin.java) <br><sub>Java &#8226; bits</sub> | Find the largest sequence of 1 that can be obtained by flipping a 0 to 1. |
|  [Conversion](src/bits/Conversion.java) <br><sub>Java &#8226; bits</sub> | Number of bits you have to flip to convert bits A to bits B |
|  [Insertion](src/bits/Insertion.java) <br><sub>Java &#8226; bits</sub> |  |
|  [PairwiseSwap](src/bits/PairwiseSwap.java) <br><sub>Java &#8226; bits</sub> | Write a program to swap odd and even bits in an integer with as few instructions as possible (e.g., bit O and bit 1 are swapped, bit 2 and bit 3 are swapped, and so on) |
|  [Node](src/graphs/commons/Node.java) <br><sub>Java &#8226; commons</sub> |  |
|  [Tree](src/graphs/commons/Tree.java) <br><sub>Java &#8226; commons</sub> |  |
|  [BidirectionalTree](src/graphs/commons/BidirectionalTree.java) <br><sub>Java &#8226; commons</sub> |  |
|  [Graph](src/graphs/commons/Graph.java) <br><sub>Java &#8226; commons</sub> |  |
|  [BitUtils](src/bits/commons/BitUtils.java) <br><sub>Java &#8226; commons</sub> |  |
|  [FizzBuzz](src/threads/FizzBuzz.java) <br><sub>Java &#8226; threads</sub> |  |
|  [DynamicGrowShrinkArray](src/algorithmdesignmanualbook/datastructures/DynamicGrowShrinkArray.java) <br><sub>Java &#8226; datastructures</sub> |  |
|  [ReverseSentence](src/algorithmdesignmanualbook/datastructures/ReverseSentence.kt) <br><sub>Kotlin &#8226; datastructures</sub> | Reverse the words in a sentence—i.e., “My name is Chris” becomes “Chris is name My.” |
|  [Node](src/algorithmdesignmanualbook/datastructures/Node.kt) <br><sub>Kotlin &#8226; datastructures</sub> |  |
|  [BinarySearchTree](src/algorithmdesignmanualbook/datastructures/BinarySearchTree.kt) <br><sub>Kotlin &#8226; datastructures</sub> |  |
|  [IdenticalBinaryTree](src/algorithmdesignmanualbook/datastructures/IdenticalBinaryTree.kt) <br><sub>Kotlin &#8226; datastructures</sub> | Given two binary tree, find if they are identical i.e. same value at the same position & same structure |
|  [SmallestNumberInRange](src/algorithmdesignmanualbook/datastructures/SmallestNumberInRange.kt) <br><sub>Kotlin &#8226; datastructures</sub> |  Suppose that we are given a sequence of n values x1, x2, ..., xn and seek to quickly answer repeated queries of the form: given i and j, find the smallest value in xi, . . . , xj. <br> Given arrays of integer [values] of size n, convert it into matrix M of nxn such that M[i][j + 1] <= M[i][j] and anything before M[i][i] is null. M[i][i] holds the ith index item of [values] |
|  [O1DataStructure](src/algorithmdesignmanualbook/datastructures/O1DataStructure.kt) <br><sub>Kotlin &#8226; datastructures</sub> | Construct a DS with search, remove and add operations of O(1) in worst case The elements are drawn from the finite set and initialization can take place at O(n) |
|  [StringPatternMatching](src/algorithmdesignmanualbook/datastructures/StringPatternMatching.kt) <br><sub>Kotlin &#8226; datastructures</sub> | Find substring match <br> O(ab) where a = len of pattern and b = len of string |
|  [CutoutsToGenerateString](src/algorithmdesignmanualbook/datastructures/CutoutsToGenerateString.kt) <br><sub>Kotlin &#8226; datastructures</sub> | You are given a search string and a magazine. You seek to generate all the characters in search string by cutting them out from the magazine. Give an algorithm to efficiently determine whether the magazine contains all the letters in the search string <br> Notes: <br>* Cases matters <br>* Whitespace doesn't matter |
|  [MatrixMultiplication](src/algorithmdesignmanualbook/datastructures/MatrixMultiplication.kt) <br><sub>Kotlin &#8226; datastructures</sub> |  |
|  [LargestOccuringOrderedPair](src/algorithmdesignmanualbook/datastructures/LargestOccuringOrderedPair.kt) <br><sub>Kotlin &#8226; datastructures</sub> |  |
|  [BalancedParentheses](src/algorithmdesignmanualbook/datastructures/BalancedParentheses.kt) <br><sub>Kotlin &#8226; datastructures</sub> | Check if a string contains properly nested and balanced parentheses, and false if otherwise. |
|  [ReverseLinkedList](src/algorithmdesignmanualbook/datastructures/ReverseLinkedList.kt) <br><sub>Kotlin &#8226; datastructures</sub> | [link here](https://leetcode.com/problems/reverse-linked-list) |
|  [MiddleNodeOfLinkedList](src/algorithmdesignmanualbook/datastructures/MiddleNodeOfLinkedList.kt) <br><sub>Kotlin &#8226; datastructures</sub> | Given a singly-linked list, find its middle node. <br> Solution: Fast pointer-slow pointer approach Use two pointer, one traverses one step ahead and another by 2 steps. When the fast pointer reaches the end, the slow pointer is at middle. |
|  [FlattenBSTIntoLinkedList](src/algorithmdesignmanualbook/datastructures/FlattenBSTIntoLinkedList.kt) <br><sub>Kotlin &#8226; datastructures</sub> |  |
|  [MultiplicativeArray](src/algorithmdesignmanualbook/datastructures/MultiplicativeArray.kt) <br><sub>Kotlin &#8226; datastructures</sub> | You have an unordered array X of n integers. Find the array M containing n elements where Mi is the product of all integers in X except for Xi. You may not use division. |
|  [NoInitializationArray](src/algorithmdesignmanualbook/datastructures/NoInitializationArray.kt) <br><sub>Kotlin &#8226; datastructures</sub> | Design a data structure that allows one to search, insert, and delete an integer X in O(1) time (i.e. , constant time, independent of the total number of integers stored). Assume that 1 ≤ X ≤ n and that there are m + n units of space available, where m is the maximum number of integers that can be in the table at any one time. (Hint: use two arrays A[1..n] and B[1..m].) You are not allowed to initialize either A or B, as that would take O(m) or O(n) operations. This means the arrays are full of random garbage to begin with, so you must be very careful. <br> [Solution link](https://research.swtch.com/sparse): <br> Two arrays both of them with garbage value <br>* dense: contains actual elements in order of insertion <br>* sparse: uses *value* of [dense] as index and stores the *index* at which the value is located <br> So the search value v is legit iff index v of sparse array points to dense's index whose value is also v |
|  [CheckBST](src/graphs/CheckBST.java) <br><sub>Java &#8226; graphs</sub> | left <= current < right |
|  [CheckBalanced](src/graphs/CheckBalanced.java) <br><sub>Java &#8226; graphs</sub> |  |
|  [PickRandomNode](src/graphs/PickRandomNode.java) <br><sub>Java &#8226; graphs</sub> |  |
|  [CheckIfSubTree](src/graphs/CheckIfSubTree.java) <br><sub>Java &#8226; graphs</sub> | Check if a tree is a subtree of another |
|  [MinimalTree](src/graphs/MinimalTree.java) <br><sub>Java &#8226; graphs</sub> | Given a sorted (increasing order) array with unique integer elements, write an algorithm to create a binary search tree with minimal height. |
|  [ListOfDepth](src/graphs/ListOfDepth.java) <br><sub>Java &#8226; graphs</sub> | Given a binary tree, design an algorithm which creates a linked list of all the nodes at each depth (e.g., if you have a tree with depth D, you'll have D linked lists). |
|  [PathWithSum](src/graphs/PathWithSum.java) <br><sub>Java &#8226; graphs</sub> |  |
|  [BuildOrder](src/graphs/BuildOrder.java) <br><sub>Java &#8226; graphs</sub> |  |
|  [FirstCommonAncestor](src/graphs/FirstCommonAncestor.java) <br><sub>Java &#8226; graphs</sub> |  |
|  [RoutesBetweenNodes](src/graphs/RoutesBetweenNodes.java) <br><sub>Java &#8226; graphs</sub> |  |
|  [IsOneStringPermutationOfOther](src/arraysandstrings/IsOneStringPermutationOfOther.java) <br><sub>Java &#8226; arraysandstrings</sub> |  |
|  [UniqueCharacters](src/arraysandstrings/UniqueCharacters.java) <br><sub>Java &#8226; arraysandstrings</sub> |  |
|  [IsPermutationOfStringAPalindrome](src/arraysandstrings/IsPermutationOfStringAPalindrome.kt) <br><sub>Kotlin &#8226; arraysandstrings</sub> |  |
|  [StringCompression](src/arraysandstrings/StringCompression.kt) <br><sub>Kotlin &#8226; arraysandstrings</sub> |  |
|  [StringRotation](src/arraysandstrings/StringRotation.kt) <br><sub>Kotlin &#8226; arraysandstrings</sub> |  |
|  [MatrixRotation](src/arraysandstrings/MatrixRotation.kt) <br><sub>Kotlin &#8226; arraysandstrings</sub> |  |
|  [OneAway](src/arraysandstrings/OneAway.kt) <br><sub>Kotlin &#8226; arraysandstrings</sub> |  |
|  [URLify](src/arraysandstrings/URLify.kt) <br><sub>Kotlin &#8226; arraysandstrings</sub> |  |
|  [AVLTree](src/algorithmsinanutshell/AVLTree.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | Always a balanced tree https://www.youtube.com/watch?v=jDM6_TnYIqE <br> To delete a non-leaf/non-root node, remove it and find the right most descendant and put it there. The child of right most descendant will replace the old position of rightmost descendant <br> Since there are fixed number of rotation, it can be considered as O(1) <br> Other variations of tree are <br>* n-way tree like B-trees <br>* red-black tree with more relaxed rotation rules and enforces height of one branch isn't greater than 2x other branch |
|  [Graph](src/algorithmsinanutshell/Graph.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> |  |
|  [TreeTraversal](src/algorithmsinanutshell/TreeTraversal.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> |  |
|  [GraphTraversal](src/algorithmsinanutshell/GraphTraversal.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | Depth First Traversal <br>Breadth First Traversal |
|  [DijkstraAlgorithm](src/algorithmsinanutshell/DijkstraAlgorithm.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> |  |
|  [PrimMinSpanningTreeAlgorithm](src/algorithmsinanutshell/PrimMinSpanningTreeAlgorithm.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | Prim Algorithm starts from min cost edge and then selects the next small cost edge while maintaining the connection with first edge. <br> This can be modeled using [PriorityQueue] sorted using [Edge] w.r.t its weight |
|  [FloydWarshallAlgorithm](src/algorithmsinanutshell/FloydWarshallAlgorithm.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | # All pair shortest path algorithm <br> While Dijkstra Shortest Path algorithm helps find shortest path between start and end vertex, [FloydWarshallAlgorithm] finds the shortest path between all vertices in a [graph] <br> [Source](https://www.youtube.com/watch?v=oNI0rf2P9gE) |
|  [LineSweepAlgorithm](src/algorithmsinanutshell/LineSweepAlgorithm.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | Given a number of lines, find the lines that intersects with each other <br> Starting from left, sweep a vertical line through each point. Find the intersection of lines with each other that the vertical lines touches. If the sweep line has moved past a line (both points are to its left), this can be ignored. <br> [link](https://www.geeksforgeeks.org/given-a-set-of-line-segments-find-if-any-two-segments-intersect/) |
|  [ConvexHullScanUsingGrahamScan](src/algorithmsinanutshell/ConvexHullScanUsingGrahamScan.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | Find Convex Hull - a polygon that surrounds all points <br> [link](https://www.cs.auckland.ac.nz/software/AlgAnim/convex_hull.html) |
|  [GreatestCommonDivisor](src/algorithmsinanutshell/GreatestCommonDivisor.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | Greatest common divisor using Euclidean Algorithm <br> [Link](https://www.freecodecamp.org/news/euclidian-gcd-algorithm-greatest-common-divisor/) |
|  [IntersectionOfLines](src/algorithmsinanutshell/IntersectionOfLines.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | Two lines (P1, P2) and (P3,P4) intersect when orientation of: <br>* (P1 wrt P3,P4) and (P2 wrt P3,P4) <br>* (P3 wrt P1,P2) and (P4 wrt P1,P2) <br> are different. <br> A line (P1, P2) can be represented as vector P1P2 and orientation is the way (whether counter-clockwise or clockwise) direction it makes fromTo move from P1P2 fromTo P3. <br> P3 o <br> P1 o----->---o P2 <br> orientation of P3 wrt P1P2 is ACW. <br> Special case is when (P1, P2) and (P3,P4) are collinear. <br> <br>* In case of non-intersecting case, orientation is 0 for both P3(P1P2) and P4(P1,P2) and vv. <br> P1 o----->---o P2   P3 o----->---o P4  (Non-intersecting case) <br> <br>* In case of intersecting case, orientation is different for both P3(P1P2) and P4(P1,P2) and vv. <br> P1 o----->--oP3-----P2o-->---o P4 (Intersecting case) <br>   [Link](https://www.youtube.com/watch?v=bbTqI0oqL5U) |
|  [OrientationOf3Points](src/algorithmsinanutshell/OrientationOf3Points.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | [Link](https://www.geeksforgeeks.org/orientation-3-ordered-points/) <br> [Related](https://youtu.be/bbTqI0oqL5U?t=161) |
|  [Network](src/algorithmsinanutshell/networkflow/Network.kt) <br><sub>Kotlin &#8226; networkflow</sub> |  |
|  [FordFulkersonAlgorithm](src/algorithmsinanutshell/networkflow/FordFulkersonAlgorithm.kt) <br><sub>Kotlin &#8226; networkflow</sub> | Algorithm to find the max flow to the sink in a given [network] <br> https://brilliant.org/wiki/ford-fulkerson-algorithm/ <br> https://www.youtube.com/watch?v=NwenwITjMys <br> O(E*mf) where E=edge, mf=value of max flow |
|  [KnapSack01](src/algorithmsinanutshell/spatialtree/KnapSack01.kt) <br><sub>Kotlin &#8226; spatialtree</sub> | Knapsack Problem: Given total capacity [totalCapacity] of a bag, how can you select subset of items of weight [weights] with profit [profits] such that the profit is maximized? <br> [Video](https://www.youtube.com/watch?v=8LusJS5-AGo) <br> <br>! P ! w ! 0 ! 1 ! 2 ! 3 ! 4 ! 5 ! 6 ! 7 ! <br>! 1 ! 1 !   !   !   !   !   !   !   !   ! <br>! 4 ! 3 !   !   !   !   !   !   !   !   ! <-- while here, everything below are ignored so w1 and w3 are considered <br>! 5 ! 4 !   !   !   !   !   !   !   !   ! <br>! 6 ! 5 !   !   !   !   !   !   !   !   ! <br> |
|  [KDTree](src/algorithmsinanutshell/spatialtree/KDTree.kt) <br><sub>Kotlin &#8226; spatialtree</sub> | K-d tree is a binary search tree with more than 1 dimensions (i.e k dimensions). <br> A 2-d tree looks like given points ((3, 6), (17, 15), (13, 15), (6, 12), (9, 1), (2, 7), (10, 19)) <br>  (3, 6)   ----> compare x coordinate /       \ (2,7)          (17, 15)     ----y  compare y /     \ (6,12)        (13,15)         ----x compare x \        / (9,1)  (10,19)        ----y <br> At each level, the dimensions of points are compared in alternating manner. <br> |
|  [QuadTree](src/algorithmsinanutshell/spatialtree/QuadTree.kt) <br><sub>Kotlin &#8226; spatialtree</sub> | https://algs4.cs.princeton.edu/92search/QuadTree.java.html <br> https://www.youtube.com/watch?v=jxbDYxm-pXg <br> https://www.youtube.com/watch?v=xFcQaig5Z2A |
|  [NearestNeighbourQueries](src/algorithmsinanutshell/spatialtree/NearestNeighbourQueries.kt) <br><sub>Kotlin &#8226; spatialtree</sub> | Given a target T and a set of points S, find the nearest neighbour of T in S. <br> https://www.youtube.com/watch?v=Glp7THUpGow <br> https://www.youtube.com/watch?v=XG4zpiJAkD4 <br> https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/kdtrees.pdf |
|  [Permutation](src/algorithmdesignmanualbook/heuristics/backtrack/Permutation.kt) <br><sub>Kotlin &#8226; backtrack</sub> |  |
|  [AllSubsets](src/algorithmdesignmanualbook/heuristics/backtrack/AllSubsets.kt) <br><sub>Kotlin &#8226; backtrack</sub> |  |
|  [PartialSumUsingFenwickTree](src/algorithmdesignmanualbook/partialsum/PartialSumUsingFenwickTree.kt) <br><sub>Kotlin &#8226; partialsum</sub> | Let A be an array of n real numbers. Design an algorithm to perform any sequence of the following operations: • Add(i,y) – Add the value y to the ith number. • Partial-sum(i) – Return the sum of the first i numbers Each operation must take O(logn). <br> Fenwick Tree or Binary Indexed Tree is a tree containing n+1 nodes. Each node's parent is right most 1 flipped i.e <br>* 8 -> 1000 so parent is 0000 (0) <br>* 7 -> 0111 so parent is 0110 (6) <br>* 10 -> 1010 so parent is 1000 (8) <br>* 5 -> 0101 so parent is 0100 (4) Sum can be obtained by (0..5) -> tree[6] + tree[4] + tree[0] i.e index+1 and then go upwards to parents <br> To get the parent: <br>* 2's complement (Flip all bits and add 1) <br>* AND it with original number <br>* Subtract it from original number <br> 7 (111) ---(step 1)---> 000+1=001 ---(AND 111)-->001 --(Subtract from 111)--->110 <br> |
|  [PartialSumUsingCumulativeSum](src/algorithmdesignmanualbook/partialsum/PartialSumUsingCumulativeSum.kt) <br><sub>Kotlin &#8226; partialsum</sub> | Let A[1..n] be an array of real numbers. Design an algorithm to perform any sequence of the following operations: • Add(i,y) – Add the value y to the ith number. • Partial-sum(i) – Return the sum of the first i numbers |
|  [MagicIndexSearch](src/algorithmdesignmanualbook/searching/MagicIndexSearch.kt) <br><sub>Kotlin &#8226; searching</sub> | [4-33] Algorithm to determine whether there exists an i index such as ai = i given array of {a1, a2, a3 ... an} Sorted and distinct case: |
|  [SmallestMissingNumber](src/algorithmdesignmanualbook/searching/SmallestMissingNumber.kt) <br><sub>Kotlin &#8226; searching</sub> | [4-34] Suppose that you are given a sorted sequence of distinct integers {a1, a2, . . . , an}, drawn from 1 to m where n < m. Give an O(lg n) algorithm to find an integer ≤ m that is not present in a. For full credit, find the smallest such integer. <br> Solution: Binary search into the array. Since its sorted and starts from index 1, every element at index i should have element i. <br> |
|  [UnionFind](src/algorithmdesignmanualbook/graph/UnionFind.kt) <br><sub>Kotlin &#8226; graph</sub> | Solution: https://www.geeksforgeeks.org/union-find/ <br> Union-Find represent each subset as backward trees <br>!  0  !  1  !  2  ! <br>!  1  !  2  !  0  ! <br> |
|  [PrimMinSpanningTree](src/algorithmdesignmanualbook/graph/PrimMinSpanningTree.kt) <br><sub>Kotlin &#8226; graph</sub> | Solution: https://www.programiz.com/dsa/prim-algorithm <br> Given vertices with weighted edges, from start vertex, chose the edge with min edge such that it doesnt form cycle. |
|  [Graph](src/algorithmdesignmanualbook/graph/Graph.kt) <br><sub>Kotlin &#8226; graph</sub> |  |
|  [SimpleGraph](src/algorithmdesignmanualbook/graph/SimpleGraph.kt) <br><sub>Kotlin &#8226; graph</sub> |  |
|  [BreadthFirstTraversal](src/algorithmdesignmanualbook/graph/BreadthFirstTraversal.kt) <br><sub>Kotlin &#8226; graph</sub> |  |
|  [FindNumberOfOccurrence](src/algorithmdesignmanualbook/sorting/FindNumberOfOccurrence.kt) <br><sub>Kotlin &#8226; sorting</sub> | Find the range in which [str] occurs in [array]. <br> [Solution here](https://tutorialspoint.dev/algorithm/searching-algorithms/count-number-of-occurrences-or-frequency-in-a-sorted-array) |
|  [KSortedListMerge](src/algorithmdesignmanualbook/sorting/KSortedListMerge.kt) <br><sub>Kotlin &#8226; sorting</sub> | Give an O(n log k)-time algorithm that merges k sorted lists with a total of n elements into one sorted list. (Hint: use a heap to speed up the elementary O(kn)-time algorithm). |
|  [ColorSortLinearTime](src/algorithmdesignmanualbook/sorting/ColorSortLinearTime.kt) <br><sub>Kotlin &#8226; sorting</sub> | Suppose an array A consists of n elements, each of which is red, white, or blue. We seek to sort the elements so that all the reds come before all the whites, which come before all the blues The only operation permitted on the keys are: examine and swap. |
|  [KSum](src/algorithmdesignmanualbook/sorting/KSum.kt) <br><sub>Kotlin &#8226; sorting</sub> | Given a set S of n integers and an integer T, give an algorithm to test whether k of the integers in S add up to T. <br> [Another way](https://www.geeksforgeeks.org/find-the-k-th-permutation-sequence-of-first-n-natural-numbers/) <br> ### IDEA: <br> For target=21, k=3 i.e. 21/3 and array: <br> <br>! 5 ! 6 ! 8 ! 10 ! 12 ! <br> <------- 21/3 ------> <br> ^ <---   16/2    ---> <br> ^ <---  10/1 ---> |
|  [TwoPairSum](src/algorithmdesignmanualbook/sorting/TwoPairSum.kt) <br><sub>Kotlin &#8226; sorting</sub> | O(nlogn) algorithm for finding whether there exists a pair of elements, one from S1 and one from S2, that add up to x |
|  [FastMedian](src/algorithmdesignmanualbook/sorting/FastMedian.kt) <br><sub>Kotlin &#8226; sorting</sub> | NO need to sort all the items. Just find the sort the items before the median index Using quicksort, find the partition. Then throw away the left partition if the median index lies in the right portion while calibrating the new median index. <br> Similar to finding the kth smallest item in the unsorted list |
|  [ArrangeNegativeThenPositiveNumber](src/algorithmdesignmanualbook/sorting/ArrangeNegativeThenPositiveNumber.kt) <br><sub>Kotlin &#8226; sorting</sub> | 4-20 Rearrange an array of n keys so that all the negative keys precede all the nonnegative keys |
|  [MergeSort](src/algorithmdesignmanualbook/sorting/MergeSort.kt) <br><sub>Kotlin &#8226; sorting</sub> |  |
|  [QuickSort](src/algorithmdesignmanualbook/sorting/QuickSort.kt) <br><sub>Kotlin &#8226; sorting</sub> |  |
|  [SelectionSort](src/algorithmdesignmanualbook/sorting/SelectionSort.kt) <br><sub>Kotlin &#8226; sorting</sub> | Identify the smallest element from unsorted portion and put it at the end of the sorted portion |
|  [InsertionSort](src/algorithmdesignmanualbook/sorting/InsertionSort.kt) <br><sub>Kotlin &#8226; sorting</sub> | How does insertion sort work? <br>* Loop through elements <br>* At each element, compare it with element before it <br>* If smaller, swap places <br>* Repeat |
|  [HeapSort](src/algorithmdesignmanualbook/sorting/HeapSort.kt) <br><sub>Kotlin &#8226; sorting</sub> |  |
|  [ColorSort](src/algorithmdesignmanualbook/sorting/ColorSort.kt) <br><sub>Kotlin &#8226; sorting</sub> | Assume that we are given n pairs of items as input, where the first item is a number and the second item is one of three colors (red, blue, or yellow). Further assume that the items are sorted by number. Give an O(n) algorithm to sort the items by color (all reds before all blues before all yellows) such that the numbers for identical colors stay sorted. <br> Solution: Maintain 3 queue for each color. At last, dequeue red, blue and then yellow |
|  [BucketSort](src/algorithmdesignmanualbook/sorting/BucketSort.kt) <br><sub>Kotlin &#8226; sorting</sub> | Maintains bucket of 0..9 or a-z The number of iterations requires depends on number of characters in longest element (length wise) <br> [Algorithm](https://www.youtube.com/watch?v=JMlYkE8hGJM) |
|  [FindTransitionIndex](src/algorithmdesignmanualbook/sorting/FindTransitionIndex.kt) <br><sub>Kotlin &#8226; sorting</sub> | Given unbounded 0s followed by unbounded number of 1s, find the first index of transition. <br> Done using ONE-SIDED BINARY SEARCH <br> Solution: <br> Incremental search 1,2,4,6,8... and then binary search on transition range |
|  [LinkedListDuplicate](src/linkedlists/LinkedListDuplicate.kt) <br><sub>Kotlin &#8226; linkedlists</sub> |  |
|  [SumLists](src/linkedlists/SumLists.kt) <br><sub>Kotlin &#8226; linkedlists</sub> |  |
|  [LinkedList](src/linkedlists/LinkedList.kt) <br><sub>Kotlin &#8226; linkedlists</sub> |  |
|  [ZigZagConversion](src/questions/ZigZagConversion.kt) <br><sub>Kotlin &#8226; questions</sub> | The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: P   A   H   N A P L S I I G Y   I   R And then read line by line: "PAHNAPLSIIGYIR" [Source](https://leetcode.com/problems/zigzag-conversion/) |
|  [SearchInsertPosition](src/questions/SearchInsertPosition.kt) <br><sub>Kotlin &#8226; questions</sub> | Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity. <br> [Source](https://leetcode.com/problems/search-insert-position/) |
|  [FormatPhoneNumber](src/questions/FormatPhoneNumber.kt) <br><sub>Kotlin &#8226; questions</sub> | Given a phone number should format in the form of abc-def-ijk. Last two part can be of 2 digits |
|  [ContainerWithMostWater](src/questions/ContainerWithMostWater.kt) <br><sub>Kotlin &#8226; questions</sub> | Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water. <img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" height="150" width="300"> [Source](https://leetcode.com/problems/container-with-most-water/) |
|  [MaxNumberOfBalloons](src/questions/MaxNumberOfBalloons.kt) <br><sub>Kotlin &#8226; questions</sub> | Given a string text, you want to use the characters of text to form as many instances of the word "balloon" as possible. You can use each character in text at most once. Return the maximum number of instances that can be formed. <br> Input: text = "nlaebolko"; Output: 1 <br> [Source](https://leetcode.com/explore/item/3973) |
|  [SearchContact](src/questions/SearchContact.kt) <br><sub>Kotlin &#8226; questions</sub> |  |
|  [LongestCommonPrefix](src/questions/LongestCommonPrefix.kt) <br><sub>Kotlin &#8226; questions</sub> | Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string "". |
|  [RemoveDuplicateFromSortedArray](src/questions/RemoveDuplicateFromSortedArray.kt) <br><sub>Kotlin &#8226; questions</sub> | Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place. The relative order of the elements should be kept the same. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums. <br> [Source](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/) |
|  [needle](python/needle.py) <br><sub>Python &#8226; python</sub> |  |
|  [longestpalindrome](python/longestpalindrome.py) <br><sub>Python &#8226; python</sub> |  |
|  [longestsubstr](python/longestsubstr.py) <br><sub>Python &#8226; python</sub> |  |
|  [sumEvenAfterQueries](python/sumEvenAfterQueries.py) <br><sub>Python &#8226; python</sub> |  |
|  [valid_paranthesis](python/valid_paranthesis.py) <br><sub>Python &#8226; python</sub> |  |
|  [three_sums](python/three_sums.py) <br><sub>Python &#8226; python</sub> |  |
|  [addTwoNumbers](python/addTwoNumbers.py) <br><sub>Python &#8226; python</sub> |  |
|  [remove_element](python/remove_element.py) <br><sub>Python &#8226; python</sub> |  |
|  [reverseint](python/reverseint.py) <br><sub>Python &#8226; python</sub> |  |
|  [paritysort](python/paritysort.py) <br><sub>Python &#8226; python</sub> |  |
|  [multiply](python/multiply.py) <br><sub>Python &#8226; python</sub> |  |
|  [stack](python/stacksqueues/stack.py) <br><sub>Python &#8226; stacksqueues</sub> |  |
|  [sort_stack](python/stacksqueues/sort_stack.py) <br><sub>Python &#8226; stacksqueues</sub> |  |
|  [stack_min](python/stacksqueues/stack_min.py) <br><sub>Python &#8226; stacksqueues</sub> |  |
|  [animal_shelter](python/stacksqueues/animal_shelter.py) <br><sub>Python &#8226; stacksqueues</sub> |  |
|  [stack_of_plates](python/stacksqueues/stack_of_plates.py) <br><sub>Python &#8226; stacksqueues</sub> |  |
|  [queueviastacks](python/stacksqueues/queueviastacks.py) <br><sub>Python &#8226; stacksqueues</sub> |  |
|  [tic_tac](python/moderate/tic_tac.py) <br><sub>Python &#8226; moderate</sub> |  |
|  [master_mind](python/moderate/master_mind.py) <br><sub>Python &#8226; moderate</sub> |  |
|  [diving_board](python/moderate/diving_board.py) <br><sub>Python &#8226; moderate</sub> | Arranging k planks end-to-end means that arranging (k short, 0 long), (k-1 short, 1 long), (k-2 short, 2 long)... <br>:param k: the number of planks <br>:return: the all possible length of arrangements |
|  [count_pairs_with_difference](python/moderate/count_pairs_with_difference.py) <br><sub>Python &#8226; moderate</sub> |  |
|  [smallest_difference](python/moderate/smallest_difference.py) <br><sub>Python &#8226; moderate</sub> |  |
|  [continuous_sequence](python/moderate/continuous_sequence.py) <br><sub>Python &#8226; moderate</sub> |  |
|  [living_people](python/moderate/living_people.py) <br><sub>Python &#8226; moderate</sub> |  |
|  [xml_encoding](python/moderate/xml_encoding.py) <br><sub>Python &#8226; moderate</sub> |  |
|  [pattern_matching](python/moderate/pattern_matching.py) <br><sub>Python &#8226; moderate</sub> | You are given two strings, pattern and value. The pattern string consists of just the letters a and b, describing a pattern within a string. For example, the string catcatgocatgo matches the pattern aabab (where cat is a and go is b). It also matches patterns like a, ab, and b. Write a method to determine if value matches pattern. |
|  [pairs_with_sum](python/moderate/pairs_with_sum.py) <br><sub>Python &#8226; moderate</sub> |  |
|  [swap_sum](python/moderate/swap_sum.py) <br><sub>Python &#8226; moderate</sub> |  |
|  [operation](python/moderate/operation.py) <br><sub>Python &#8226; moderate</sub> |  |
|  [intersection](python/moderate/intersection.py) <br><sub>Python &#8226; moderate</sub> |  |
|  [calculator](python/moderate/calculator.py) <br><sub>Python &#8226; moderate</sub> |  |
|  [bisect_squares](python/moderate/bisect_squares.py) <br><sub>Python &#8226; moderate</sub> |  |
|  [pond_sizes](python/moderate/pond_sizes.py) <br><sub>Python &#8226; moderate</sub> | You have an integer matrix representing a plot of land, where the value at that location represents the height above sea level. A value of zero indicates water. A pond is a region of water connected vertically, horizontally, or diagonally. The size of the pond is the total number of connected water cells. Write a method to compute the sizes of all ponds in the matrix |
|  [factorial_zeros](python/moderate/factorial_zeros.py) <br><sub>Python &#8226; moderate</sub> |  |
|  [langton_ant](python/moderate/langton_ant.py) <br><sub>Python &#8226; moderate</sub> |  |
|  [english_int](python/moderate/english_int.py) <br><sub>Python &#8226; moderate</sub> |  |
|  [sub_sort](python/moderate/sub_sort.py) <br><sub>Python &#8226; moderate</sub> |  |
|  [delete_middle](python/codinginterview/delete_middle.py) <br><sub>Python &#8226; codinginterview</sub> | Delete kth node from linked list <br> Parameters: linked_ (LinkedList): a Linked List k (int): the kth position <br> |
|  [is_linked_list_palindrome](python/codinginterview/is_linked_list_palindrome.py) <br><sub>Python &#8226; codinginterview</sub> | Check if a linked list is a palindrome |
|  [string_compression](python/codinginterview/string_compression.py) <br><sub>Python &#8226; codinginterview</sub> |  |
|  [string_rotation](python/codinginterview/string_rotation.py) <br><sub>Python &#8226; codinginterview</sub> | Check if one string is formed by rotating the other string eg: abcd, dabc, cdab, bcda |
|  [matrix_rotation](python/codinginterview/matrix_rotation.py) <br><sub>Python &#8226; codinginterview</sub> |  |
|  [is_palindrome_permutation](python/codinginterview/is_palindrome_permutation.py) <br><sub>Python &#8226; codinginterview</sub> | 195. Palindrome Permutation: Given a string, write a function to check if it is a permutation of a palindrome. |
|  [is_linked_list_circular](python/codinginterview/is_linked_list_circular.py) <br><sub>Python &#8226; codinginterview</sub> | Detect if a Linked List is circular |
|  [delete_duplicates](python/codinginterview/delete_duplicates.py) <br><sub>Python &#8226; codinginterview</sub> | Delete duplicate node from a Linked List <br> Parameters: linked_list: The list to be deleted from |
|  [merge_sort](python/codinginterview/merge_sort.py) <br><sub>Python &#8226; codinginterview</sub> |  |
|  [quick_sort](python/codinginterview/quick_sort.py) <br><sub>Python &#8226; codinginterview</sub> |  |
|  [kth_to_last](python/codinginterview/kth_to_last.py) <br><sub>Python &#8226; codinginterview</sub> | Get all nodes from kth position to the end |
|  [sum_of_nodes_of_linked_list](python/codinginterview/sum_of_nodes_of_linked_list.py) <br><sub>Python &#8226; codinginterview</sub> | Sum value of nodes 7 -> 1 -> 6 + 5 -> 9 -> 2 = 617+295 = 2 -> 1 -> 9 |
|  [forward_sum_of_nodes_of_linked_list](python/codinginterview/forward_sum_of_nodes_of_linked_list.py) <br><sub>Python &#8226; codinginterview</sub> | (6 -> 1 -> 7) + (2 -> 9). That is 617 + 029 = 6 -> 4 -> 6 |
|  [find_intersection_between_two_linked_list](python/codinginterview/find_intersection_between_two_linked_list.py) <br><sub>Python &#8226; codinginterview</sub> | Find intersection between two linked list |
|  [zero_matrix](python/codinginterview/zero_matrix.py) <br><sub>Python &#8226; codinginterview</sub> | Make INPLACE row and column of a matrix 0 iff that row contains a 0 |
|  [one_or_zero_edits_away](python/codinginterview/one_or_zero_edits_away.py) <br><sub>Python &#8226; codinginterview</sub> |  |
|  [node](python/codinginterview/shared/node.py) <br><sub>Python &#8226; shared</sub> |  |
|  [linked_list](python/codinginterview/shared/linked_list.py) <br><sub>Python &#8226; shared</sub> |  |
|  [reversed_linked_list](python/codinginterview/shared/reversed_linked_list.py) <br><sub>Python &#8226; shared</sub> |  |
|  [base_linked_list](python/codinginterview/shared/base_linked_list.py) <br><sub>Python &#8226; shared</sub> |  |
|  [circular_linked_list](python/codinginterview/shared/circular_linked_list.py) <br><sub>Python &#8226; shared</sub> |  |

 ___
 <sub>This README was auto-generated during pre-commit.</sub>
