
# algorithms :robot:

Collection of Data Structures and Algorithms solutions

### Contents
| Filename | Description |
|  --- | --- |
|  [TowerOfHanoi](src/dynamic/TowerOfHanoi.java) <br><sub>Java</sub> |  |
|  [PaintFill](src/dynamic/PaintFill.java) <br><sub>Java</sub> |  |
|  [BooleanEvaluation](src/dynamic/BooleanEvaluation.java) <br><sub>Java</sub> |  |
|  [PermutationWithDuplicates](src/dynamic/PermutationWithDuplicates.java) <br><sub>Java</sub> |  |
|  [PermutationWithoutDuplicates](src/dynamic/PermutationWithoutDuplicates.java) <br><sub>Java</sub> |  |
|  [EightQueens](src/dynamic/EightQueens.java) <br><sub>Java</sub> |  |
|  [Parens](src/dynamic/Parens.java) <br><sub>Java</sub> |  |
|  [Coins](src/dynamic/Coins.java) <br><sub>Java</sub> |  |
|  [RecursiveMultiply](src/dynamic/RecursiveMultiply.java) <br><sub>Java</sub> |  |
|  [EditDistance](src/algorithmdesignmanualbook/dynamic/EditDistance.kt) <br><sub>Kotlin</sub> |  |
|  [MinDifferenceBetweenSubsets](src/algorithmdesignmanualbook/dynamic/MinDifferenceBetweenSubsets.kt) <br><sub>Kotlin</sub> |  |
|  [SortedMerge](src/sortingandsearch/SortedMerge.java) <br><sub>Java</sub> |  |
|  [SortedSearchNoSize](src/sortingandsearch/SortedSearchNoSize.java) <br><sub>Java</sub> |  |
|  [SparseSearch](src/sortingandsearch/SparseSearch.java) <br><sub>Java</sub> |  |
|  [SortedMatrixSearch](src/sortingandsearch/SortedMatrixSearch.java) <br><sub>Java</sub> |  |
|  [RankFromStream](src/sortingandsearch/RankFromStream.java) <br><sub>Java</sub> |  |
|  [GroupAnagrams](src/sortingandsearch/GroupAnagrams.java) <br><sub>Java</sub> |  |
|  [PeaksAndValley](src/sortingandsearch/PeaksAndValley.java) <br><sub>Java</sub> |  |
|  [Shuffle](src/hard/Shuffle.java) <br><sub>Java</sub> |  |
|  [AddWithoutPlus](src/hard/AddWithoutPlus.java) <br><sub>Java</sub> |  |
|  [RandomSet](src/hard/RandomSet.java) <br><sub>Java</sub> |  |
|  [count_of_2s](python/hard/count_of_2s.py) <br><sub>Python</sub> | Find the number of 2s in between 0 and n<br>:param number: the max value (inclusive)<br>:return: Number of 2s |
|  [baby_names](python/hard/baby_names.py) <br><sub>Python</sub> |  |
|  [letters_and_numbers](python/hard/letters_and_numbers.py) <br><sub>Python</sub> |  |
|  [PowerOf2](src/bigo/PowerOf2.java) <br><sub>Java</sub> |  |
|  [PermutationCount](src/bigo/PermutationCount.java) <br><sub>Java</sub> |  |
|  [BinaryToString](src/bits/BinaryToString.java) <br><sub>Java</sub> |  Given a real number between 0 & 1 (eg. 0.72) that is passed in as double, print the binary representation. <br> If # cannot be expressed in binary with at most 32 bits, then throw ERROR. |
|  [FlipBitToWin](src/bits/FlipBitToWin.java) <br><sub>Java</sub> |  |
|  [Conversion](src/bits/Conversion.java) <br><sub>Java</sub> |  |
|  [Insertion](src/bits/Insertion.java) <br><sub>Java</sub> |  |
|  [PairwiseSwap](src/bits/PairwiseSwap.java) <br><sub>Java</sub> |  |
|  [Node](src/graphs/commons/Node.java) <br><sub>Java</sub> |  |
|  [Tree](src/graphs/commons/Tree.java) <br><sub>Java</sub> |  |
|  [BidirectionalTree](src/graphs/commons/BidirectionalTree.java) <br><sub>Java</sub> |  |
|  [State](src/graphs/commons/State.java) <br><sub>Java</sub> |  |
|  [Graph](src/graphs/commons/Graph.java) <br><sub>Java</sub> |  |
|  [BitUtils](src/bits/commons/BitUtils.java) <br><sub>Java</sub> |  |
|  [FizzBuzz](src/threads/FizzBuzz.java) <br><sub>Java</sub> |  |
|  [DynamicGrowShrinkArray](src/algorithmdesignmanualbook/datastructures/DynamicGrowShrinkArray.java) <br><sub>Java</sub> |  |
|  [ReverseSentence](src/algorithmdesignmanualbook/datastructures/ReverseSentence.kt) <br><sub>Kotlin</sub> |  |
|  [Node](src/algorithmdesignmanualbook/datastructures/Node.kt) <br><sub>Kotlin</sub> |  |
|  [BinarySearchTree](src/algorithmdesignmanualbook/datastructures/BinarySearchTree.kt) <br><sub>Kotlin</sub> |  |
|  [IdenticalBinaryTree](src/algorithmdesignmanualbook/datastructures/IdenticalBinaryTree.kt) <br><sub>Kotlin</sub> |  Given two binary tree, find if they are identical i.e. same value at the same position & same structure |
|  [SmallestNumberInRange](src/algorithmdesignmanualbook/datastructures/SmallestNumberInRange.kt) <br><sub>Kotlin</sub> |  <br> Suppose that we are given a sequence of n values x1, x2, ..., xn and seek to <br> quickly answer repeated queries of the form: given i and j, find the smallest value <br> in xi, . . . , xj. <br> <br> Given arrays of integer [values] of size n, convert it into matrix M of nxn <br> such that M[i][j + 1] <= M[i][j] and anything before M[i][i] is null. M[i][i] holds the ith index item of [values] |
|  [O1DataStructure](src/algorithmdesignmanualbook/datastructures/O1DataStructure.kt) <br><sub>Kotlin</sub> |  Construct a DS with search, remove and add operations of O(1) in worst case <br> The elements are drawn from the finite set and initialization can take place at O(n) |
|  [StringPatternMatching](src/algorithmdesignmanualbook/datastructures/StringPatternMatching.kt) <br><sub>Kotlin</sub> |  |
|  [CutoutsToGenerateString](src/algorithmdesignmanualbook/datastructures/CutoutsToGenerateString.kt) <br><sub>Kotlin</sub> |  |
|  [MatrixMultiplication](src/algorithmdesignmanualbook/datastructures/MatrixMultiplication.kt) <br><sub>Kotlin</sub> |  |
|  [LargestOccuringOrderedPair](src/algorithmdesignmanualbook/datastructures/LargestOccuringOrderedPair.kt) <br><sub>Kotlin</sub> |  |
|  [BalancedParentheses](src/algorithmdesignmanualbook/datastructures/BalancedParentheses.kt) <br><sub>Kotlin</sub> |  |
|  [ReverseLinkedList](src/algorithmdesignmanualbook/datastructures/ReverseLinkedList.kt) <br><sub>Kotlin</sub> |  |
|  [MiddleNodeOfLinkedList](src/algorithmdesignmanualbook/datastructures/MiddleNodeOfLinkedList.kt) <br><sub>Kotlin</sub> |  |
|  [FlattenBSTIntoLinkedList](src/algorithmdesignmanualbook/datastructures/FlattenBSTIntoLinkedList.kt) <br><sub>Kotlin</sub> |  |
|  [MultiplicativeArray](src/algorithmdesignmanualbook/datastructures/MultiplicativeArray.kt) <br><sub>Kotlin</sub> |  <br> Given array A, maintain two arrays <br> * X: holds product of `A[0]..A[i]` at index i <br> * Y: holds product of `A[lastIndex]..A[i]` at index i <br> <br> So now the item of result at index i is `X[i-1] * Y[i+1]` <br> [Solution here](https://www.geeksforgeeks.org/a-product-array-puzzle/) |
|  [NoInitializationArray](src/algorithmdesignmanualbook/datastructures/NoInitializationArray.kt) <br><sub>Kotlin</sub> |  Design a data structure that allows one to search, insert, and delete an integer <br> X in O(1) time (i.e. , constant time, independent of the total number of integers <br> stored). Assume that 1 ≤ X ≤ n and that there are m + n units of space available, <br> where m is the maximum number of integers that can be in the table at any one <br> time. (Hint: use two arrays A[1..n] and B[1..m].) You are not allowed to initialize <br> either A or B, as that would take O(m) or O(n) operations. This means the arrays <br> are full of random garbage to begin with, so you must be very careful. <br> <br> [Solution link]((https://research.swtch.com/sparse)): <br> <br> Two arrays both of them with garbage value <br> * dense: contains actual elements in order of insertion <br> * sparse: uses *value* of [dense] as index and stores the *index* at which the value is located <br> <br> So the search value v is legit iff index v of sparse array points to dense's index whose value is also v |
|  [CheckBST](src/graphs/CheckBST.java) <br><sub>Java</sub> |  left <= current < right |
|  [CheckBalanced](src/graphs/CheckBalanced.java) <br><sub>Java</sub> |  |
|  [PickRandomNode](src/graphs/PickRandomNode.java) <br><sub>Java</sub> |  |
|  [CheckIfSubTree](src/graphs/CheckIfSubTree.java) <br><sub>Java</sub> |  |
|  [MinimalTree](src/graphs/MinimalTree.java) <br><sub>Java</sub> |  Given a sorted (increasing order) array with unique integer elements, write <br> an algorithm to create a binary search tree with minimal height. |
|  [ListOfDepth](src/graphs/ListOfDepth.java) <br><sub>Java</sub> |  Given a binary tree, design an algorithm which creates a linked list of all <br> the nodes at each depth (e.g., if you have a tree with depth D, you'll have D <br> linked lists). |
|  [PathWithSum](src/graphs/PathWithSum.java) <br><sub>Java</sub> |  |
|  [BuildOrder](src/graphs/BuildOrder.java) <br><sub>Java</sub> |  |
|  [FirstCommonAncestor](src/graphs/FirstCommonAncestor.java) <br><sub>Java</sub> |  |
|  [RoutesBetweenNodes](src/graphs/RoutesBetweenNodes.java) <br><sub>Java</sub> |  |
|  [IsOneStringPermutationOfOther](src/arraysandstrings/IsOneStringPermutationOfOther.java) <br><sub>Java</sub> |  |
|  [UniqueCharacters](src/arraysandstrings/UniqueCharacters.java) <br><sub>Java</sub> |  |
|  [URLify](src/arraysandstrings/URLify.java) <br><sub>Java</sub> |  |
|  [IsPermutationOfStringAPalindrome](src/arraysandstrings/IsPermutationOfStringAPalindrome.kt) <br><sub>Kotlin</sub> |  |
|  [StringCompression](src/arraysandstrings/StringCompression.kt) <br><sub>Kotlin</sub> |  |
|  [StringRotation](src/arraysandstrings/StringRotation.kt) <br><sub>Kotlin</sub> |  |
|  [MatrixRotation](src/arraysandstrings/MatrixRotation.kt) <br><sub>Kotlin</sub> |  |
|  [OneAway](src/arraysandstrings/OneAway.kt) <br><sub>Kotlin</sub> |  |
|  [URLify](src/arraysandstrings/URLify.kt) <br><sub>Kotlin</sub> |  |
|  [AVLTree](src/algorithmsinanutshell/AVLTree.kt) <br><sub>Kotlin</sub> |  Always a balanced tree <br> https://www.youtube.com/watch?v=jDM6_TnYIqE <br> <br> To delete a non-leaf/non-root node, remove it and find the right most descendant and put it there. <br> The child of right most descendant will replace the old position of rightmost descendant <br> <br> Since there are fixed number of rotation, it can be considered as O(1) <br> <br> Other variations of tree are <br>  * n-way tree like B-trees <br>  * red-black tree with more relaxed rotation rules and enforces height of one branch isn't greater than 2x other branch |
|  [Graph](src/algorithmsinanutshell/Graph.kt) <br><sub>Kotlin</sub> |  |
|  [TreeTraversal](src/algorithmsinanutshell/TreeTraversal.kt) <br><sub>Kotlin</sub> |  |
|  [GraphTraversal](src/algorithmsinanutshell/GraphTraversal.kt) <br><sub>Kotlin</sub> |  |
|  [LineModel](src/algorithmsinanutshell/LineModel.kt) <br><sub>Kotlin</sub> |  |
|  [DijkstraAlgorithm](src/algorithmsinanutshell/DijkstraAlgorithm.kt) <br><sub>Kotlin</sub> |  |
|  [PrimMinSpanningTreeAlgorithm](src/algorithmsinanutshell/PrimMinSpanningTreeAlgorithm.kt) <br><sub>Kotlin</sub> |  Prim Algorithm starts from min cost edge and then selects the next small cost edge <br> while maintaining the connection with first edge. <br> <br> This can be modeled using [PriorityQueue] sorted using [Edge] w.r.t its weight |
|  [FloydWarshallAlgorithm](src/algorithmsinanutshell/FloydWarshallAlgorithm.kt) <br><sub>Kotlin</sub> |  # All pair shortest path algorithm <br> <br> While Dijkstra Shortest Path algorithm helps find shortest path between start and end vertex, [FloydWarshallAlgorithm] <br> finds the shortest path between all vertices in a [graph] <br> <br> [Source](https://www.youtube.com/watch?v=oNI0rf2P9gE) |
|  [LineSweepAlgorithm](src/algorithmsinanutshell/LineSweepAlgorithm.kt) <br><sub>Kotlin</sub> |  Given a number of lines, find the lines that intersects with each other <br> <br> Starting from left, sweep a vertical line through each point. Find the intersection of lines with each other <br> that the vertical lines touches. If the sweep line has moved past a line (both points are to its left), <br> this can be ignored. <br> <br> [link](https://www.geeksforgeeks.org/given-a-set-of-line-segments-find-if-any-two-segments-intersect/) |
|  [ConvexHullScanUsingGrahamScan](src/algorithmsinanutshell/ConvexHullScanUsingGrahamScan.kt) <br><sub>Kotlin</sub> |  Find Convex Hull - a polygon that surrounds all points <br> <br> [link](https://www.cs.auckland.ac.nz/software/AlgAnim/convex_hull.html) |
|  [GreatestCommonDivisor](src/algorithmsinanutshell/GreatestCommonDivisor.kt) <br><sub>Kotlin</sub> |  |
|  [IntersectionOfLines](src/algorithmsinanutshell/IntersectionOfLines.kt) <br><sub>Kotlin</sub> |  Two lines (P1, P2) and (P3,P4) intersect when orientation of: <br> * (P1 wrt P3,P4) and (P2 wrt P3,P4) <br> * (P3 wrt P1,P2) and (P4 wrt P1,P2) <br> <br> are different. <br> <br> A line (P1, P2) can be represented as vector P1P2 and orientation is the way (whether counter-clockwise or clockwise) <br> direction it makes fromTo move from P1P2 fromTo P3. <br> <br>           P3 o <br> <br>       P1 o----->---o P2 <br> <br>   orientation of P3 wrt P1P2 is ACW. <br> <br> Special case is when (P1, P2) and (P3,P4) are collinear. <br> <br>  * In case of non-intersecting case, orientation is 0 for both P3(P1P2) and P4(P1,P2) and vv. <br> <br>       P1 o----->---o P2   P3 o----->---o P4  (Non-intersecting case) <br> <br>  * In case of intersecting case, orientation is different for both P3(P1P2) and P4(P1,P2) and vv. <br> <br>       P1 o----->--oP3-----P2o-->---o P4 (Intersecting case) <br> <br> <br> <br> [Link](https://www.youtube.com/watch?v=bbTqI0oqL5U) |
|  [OrientationOf3Points](src/algorithmsinanutshell/OrientationOf3Points.kt) <br><sub>Kotlin</sub> |  [Link](https://www.geeksforgeeks.org/orientation-3-ordered-points/) <br> <br> [Related](https://youtu.be/bbTqI0oqL5U?t=161) |
|  [Network](src/algorithmsinanutshell/networkflow/Network.kt) <br><sub>Kotlin</sub> |  |
|  [FordFulkersonAlgorithm](src/algorithmsinanutshell/networkflow/FordFulkersonAlgorithm.kt) <br><sub>Kotlin</sub> |  Algorithm to find the max flow to the sink in a given [network] <br> <br> https://brilliant.org/wiki/ford-fulkerson-algorithm/ <br> <br> https://www.youtube.com/watch?v=NwenwITjMys <br> <br> O(E*mf) where E=edge, mf=value of max flow |
|  [KnapSack01](src/algorithmsinanutshell/spatialtree/KnapSack01.kt) <br><sub>Kotlin</sub> |  Knapsack Problem: Given total capacity [totalCapacity] of a bag, <br> how can you select subset of items of weight [weights] with profit [profits] such that the profit is maximized? <br> <br> [Video](https://www.youtube.com/watch?v=8LusJS5-AGo) <br> <br> | P | w | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | <br> | 1 | 1 |   |   |   |   |   |   |   |   | <br> | 4 | 3 |   |   |   |   |   |   |   |   | <-- while here, everything below are ignored so w1 and w3 are considered <br> | 5 | 4 |   |   |   |   |   |   |   |   | <br> | 6 | 5 |   |   |   |   |   |   |   |   | <br> |
|  [KDTree](src/algorithmsinanutshell/spatialtree/KDTree.kt) <br><sub>Kotlin</sub> |  K-d tree is a binary search tree with more than 1 dimensions (i.e k dimensions). <br> <br> A 2-d tree looks like given points {{3, 6}, {17, 15}, {13, 15}, {6, 12}, {9, 1}, {2, 7}, {10, 19}} <br> <br> <br>            (3, 6)   ----> compare x coordinate <br>           /       \ <br>    (2,7)          (17, 15)     ----y  compare y <br>                      /     \ <br>               (6,12)        (13,15)         ----x compare x <br>                    \        / <br>                   (9,1)  (10,19)        ----y <br> <br> At each level, the dimensions of points are compared in alternating manner. <br> |
|  [QuadTree](src/algorithmsinanutshell/spatialtree/QuadTree.kt) <br><sub>Kotlin</sub> |  https://algs4.cs.princeton.edu/92search/QuadTree.java.html <br> <br> https://www.youtube.com/watch?v=jxbDYxm-pXg <br> <br> https://www.youtube.com/watch?v=xFcQaig5Z2A |
|  [NearestNeighbourQueries](src/algorithmsinanutshell/spatialtree/NearestNeighbourQueries.kt) <br><sub>Kotlin</sub> |  Given a target T and a set of points S, find the nearest neighbour of T in S. <br> <br> https://www.youtube.com/watch?v=Glp7THUpGow <br> <br> https://www.youtube.com/watch?v=XG4zpiJAkD4 <br> <br> https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/kdtrees.pdf |
|  [Permutation](src/algorithmdesignmanualbook/heuristics/backtrack/Permutation.kt) <br><sub>Kotlin</sub> |  |
|  [AllSubsets](src/algorithmdesignmanualbook/heuristics/backtrack/AllSubsets.kt) <br><sub>Kotlin</sub> |  |
|  [PartialSumUsingFenwickTree](src/algorithmdesignmanualbook/partialsum/PartialSumUsingFenwickTree.kt) <br><sub>Kotlin</sub> |  Let A be an array of n real numbers. Design an algorithm to perform any sequence of the following operations: <br> • Add(i,y) – Add the value y to the ith number. <br> • Partial-sum(i) – Return the sum of the first i numbers <br> Each operation must take O(logn). <br> <br> Fenwick Tree or Binary Indexed Tree is a tree containing n+1 nodes. <br> Each node's parent is right most 1 flipped i.e <br> * 8 -> 1000 so parent is 0000 (0) <br> * 7 -> 0111 so parent is 0110 (6) <br> * 10 -> 1010 so parent is 1000 (8) <br> * 5 -> 0101 so parent is 0100 (4) <br> Sum can be obtained by (0..5) -> tree[6] + tree[4] + tree[0] i.e index+1 and then go upwards to parents <br> <br> To get the parent: <br> > * 2's complement (Flip all bits and add 1) <br> > * AND it with original number <br> > * Subtract it from original number <br> 7 (111) ---(step 1)---> 000+1=001 ---(AND 111)-->001 --(Subtract from 111)--->110 <br> |
|  [PartialSumUsingCumulativeSum](src/algorithmdesignmanualbook/partialsum/PartialSumUsingCumulativeSum.kt) <br><sub>Kotlin</sub> |  |
|  [MagicIndexSearch](src/algorithmdesignmanualbook/searching/MagicIndexSearch.kt) <br><sub>Kotlin</sub> |  |
|  [SmallestMissingNumber](src/algorithmdesignmanualbook/searching/SmallestMissingNumber.kt) <br><sub>Kotlin</sub> |  |
|  [UnionFind](src/algorithmdesignmanualbook/graph/UnionFind.kt) <br><sub>Kotlin</sub> |  |
|  [PrimMinSpanningTree](src/algorithmdesignmanualbook/graph/PrimMinSpanningTree.kt) <br><sub>Kotlin</sub> |  |
|  [BreadthFirstSearch](src/algorithmdesignmanualbook/graph/BreadthFirstSearch.kt) <br><sub>Kotlin</sub> |  |
|  [Graph](src/algorithmdesignmanualbook/graph/Graph.kt) <br><sub>Kotlin</sub> |  |
|  [SimpleGraph](src/algorithmdesignmanualbook/graph/SimpleGraph.kt) <br><sub>Kotlin</sub> |  |
|  [GraphInit](src/algorithmdesignmanualbook/graph/GraphInit.kt) <br><sub>Kotlin</sub> |  |
|  [FindNumberOfOccurence](src/algorithmdesignmanualbook/sorting/FindNumberOfOccurence.kt) <br><sub>Kotlin</sub> |  |
|  [KSortedListMerge](src/algorithmdesignmanualbook/sorting/KSortedListMerge.kt) <br><sub>Kotlin</sub> |  |
|  [ColorSortLinearTime](src/algorithmdesignmanualbook/sorting/ColorSortLinearTime.kt) <br><sub>Kotlin</sub> |  |
|  [KSum](src/algorithmdesignmanualbook/sorting/KSum.kt) <br><sub>Kotlin</sub> |  Given a set S of n integers and an integer T, <br> give an algorithm to test whether k of the integers in S add up to T. <br> <br> [Another way](https://www.geeksforgeeks.org/find-the-k-th-permutation-sequence-of-first-n-natural-numbers/) <br> <br> ### IDEA: <br> <br> For target=21, k=3 i.e. 21/3 and array: <br> <br> | 5 | 6 | 8 | 10 | 12 | <br> <br>  <------- 21/3 ------> <br> <br>   ^ <---   16/2    ---> <br> <br>       ^ <---  10/1 ---> |
|  [TwoPairSum](src/algorithmdesignmanualbook/sorting/TwoPairSum.kt) <br><sub>Kotlin</sub> |  |
|  [FindMedian](src/algorithmdesignmanualbook/sorting/FindMedian.kt) <br><sub>Kotlin</sub> |  |
|  [NegativePositiveNumberArrangement](src/algorithmdesignmanualbook/sorting/NegativePositiveNumberArrangement.kt) <br><sub>Kotlin</sub> |  |
|  [MergeSort](src/algorithmdesignmanualbook/sorting/MergeSort.kt) <br><sub>Kotlin</sub> |  |
|  [QuickSort](src/algorithmdesignmanualbook/sorting/QuickSort.kt) <br><sub>Kotlin</sub> |  |
|  [SelectionSort](src/algorithmdesignmanualbook/sorting/SelectionSort.kt) <br><sub>Kotlin</sub> |  |
|  [InsertionSort](src/algorithmdesignmanualbook/sorting/InsertionSort.kt) <br><sub>Kotlin</sub> |  |
|  [HeapSort](src/algorithmdesignmanualbook/sorting/HeapSort.kt) <br><sub>Kotlin</sub> |  |
|  [ColorSort](src/algorithmdesignmanualbook/sorting/ColorSort.kt) <br><sub>Kotlin</sub> |  |
|  [BucketSort](src/algorithmdesignmanualbook/sorting/BucketSort.kt) <br><sub>Kotlin</sub> |  Maintains bucket of 0..9 or a-z <br> The number of iterations requires depends on number of characters in longest element (length wise) <br> <br> [Algorithm](https://www.youtube.com/watch?v=JMlYkE8hGJM) |
|  [TransitionIndex](src/algorithmdesignmanualbook/sorting/TransitionIndex.kt) <br><sub>Kotlin</sub> |  |
|  [LinkedListDuplicate](src/linkedlists/LinkedListDuplicate.kt) <br><sub>Kotlin</sub> |  |
|  [SumLists](src/linkedlists/SumLists.kt) <br><sub>Kotlin</sub> |  |
|  [LinkedList](src/linkedlists/LinkedList.kt) <br><sub>Kotlin</sub> |  |
|  [FormatPhoneNumber](src/questions/FormatPhoneNumber.kt) <br><sub>Kotlin</sub> |  Given a phone number should format in the form of abc-def-ijk. Last two part can be of 2 digits |
|  [SearchContact](src/questions/SearchContact.kt) <br><sub>Kotlin</sub> |  |
|  [needle](python/needle.py) <br><sub>Python</sub> |  |
|  [longestpalindrome](python/longestpalindrome.py) <br><sub>Python</sub> |  |
|  [longestsubstr](python/longestsubstr.py) <br><sub>Python</sub> |  |
|  [sumEvenAfterQueries](python/sumEvenAfterQueries.py) <br><sub>Python</sub> |  |
|  [valid_paranthesis](python/valid_paranthesis.py) <br><sub>Python</sub> |  |
|  [three_sums](python/three_sums.py) <br><sub>Python</sub> |  |
|  [addTwoNumbers](python/addTwoNumbers.py) <br><sub>Python</sub> |  |
|  [remove_element](python/remove_element.py) <br><sub>Python</sub> |  |
|  [reverseint](python/reverseint.py) <br><sub>Python</sub> |  |
|  [paritysort](python/paritysort.py) <br><sub>Python</sub> |  |
|  [multiply](python/multiply.py) <br><sub>Python</sub> |  |
|  [stack](python/stacksqueues/stack.py) <br><sub>Python</sub> |  |
|  [sort_stack](python/stacksqueues/sort_stack.py) <br><sub>Python</sub> |  |
|  [stack_min](python/stacksqueues/stack_min.py) <br><sub>Python</sub> |  |
|  [animal_shelter](python/stacksqueues/animal_shelter.py) <br><sub>Python</sub> |  |
|  [stack_of_plates](python/stacksqueues/stack_of_plates.py) <br><sub>Python</sub> |  |
|  [queueviastacks](python/stacksqueues/queueviastacks.py) <br><sub>Python</sub> |  |
|  [tic_tac](python/moderate/tic_tac.py) <br><sub>Python</sub> |  |
|  [master_mind](python/moderate/master_mind.py) <br><sub>Python</sub> |  |
|  [diving_board](python/moderate/diving_board.py) <br><sub>Python</sub> | Arranging k planks end-to-end means that arranging (k short, 0 long), (k-1 short, 1 long), (k-2 short, 2 long)...<br>:param k: the number of planks<br>:return: the all possible length of arrangements |
|  [count_pairs_with_difference](python/moderate/count_pairs_with_difference.py) <br><sub>Python</sub> |  |
|  [smallest_difference](python/moderate/smallest_difference.py) <br><sub>Python</sub> |  |
|  [continuous_sequence](python/moderate/continuous_sequence.py) <br><sub>Python</sub> |  |
|  [living_people](python/moderate/living_people.py) <br><sub>Python</sub> |  |
|  [xml_encoding](python/moderate/xml_encoding.py) <br><sub>Python</sub> |  |
|  [pattern_matching](python/moderate/pattern_matching.py) <br><sub>Python</sub> | You are given two strings, pattern and value. The pattern string consists of just the letters a and b,<br>describing a pattern within a string. For example, the string catcatgocatgo<br>matches the pattern aabab (where cat is a and go is b). It also matches patterns like a, ab, and b.<br>Write a method to determine if value matches pattern. |
|  [pairs_with_sum](python/moderate/pairs_with_sum.py) <br><sub>Python</sub> |  |
|  [swap_sum](python/moderate/swap_sum.py) <br><sub>Python</sub> |  |
|  [operation](python/moderate/operation.py) <br><sub>Python</sub> |  |
|  [intersection](python/moderate/intersection.py) <br><sub>Python</sub> |  |
|  [calculator](python/moderate/calculator.py) <br><sub>Python</sub> |  |
|  [bisect_squares](python/moderate/bisect_squares.py) <br><sub>Python</sub> |  |
|  [pond_sizes](python/moderate/pond_sizes.py) <br><sub>Python</sub> | You have an integer matrix representing a plot of land, where the value at that location<br>represents the height above sea level. A value of zero indicates water. A pond is a region of water<br>connected vertically, horizontally, or diagonally. The size of the pond is the total number of<br>connected water cells. Write a method to compute the sizes of all ponds in the matrix |
|  [factorial_zeros](python/moderate/factorial_zeros.py) <br><sub>Python</sub> |  |
|  [langton_ant](python/moderate/langton_ant.py) <br><sub>Python</sub> |  |
|  [english_int](python/moderate/english_int.py) <br><sub>Python</sub> |  |
|  [sub_sort](python/moderate/sub_sort.py) <br><sub>Python</sub> |  |
|  [delete_middle](python/codinginterview/delete_middle.py) <br><sub>Python</sub> | Delete kth node from linked list<br><br>Parameters:<br>linked_ (LinkedList): a Linked List<br>k (int): the kth position<br> |
|  [is_linked_list_palindrome](python/codinginterview/is_linked_list_palindrome.py) <br><sub>Python</sub> | Check if a linked list is a palindrome |
|  [string_compression](python/codinginterview/string_compression.py) <br><sub>Python</sub> |  |
|  [string_rotation](python/codinginterview/string_rotation.py) <br><sub>Python</sub> | Check if one string is formed by rotating the other string eg: abcd, dabc, cdab, bcda |
|  [matrix_rotation](python/codinginterview/matrix_rotation.py) <br><sub>Python</sub> |  |
|  [is_palindrome_permutation](python/codinginterview/is_palindrome_permutation.py) <br><sub>Python</sub> | 195. Palindrome Permutation: Given a string, write a function to check if it is a permutation of a palindrome. |
|  [is_linked_list_circular](python/codinginterview/is_linked_list_circular.py) <br><sub>Python</sub> | Detect if a Linked List is circular |
|  [delete_duplicates](python/codinginterview/delete_duplicates.py) <br><sub>Python</sub> | Delete duplicate node from a Linked List<br><br>Parameters:<br>linked_list: The list to be deleted from |
|  [merge_sort](python/codinginterview/merge_sort.py) <br><sub>Python</sub> |  |
|  [quick_sort](python/codinginterview/quick_sort.py) <br><sub>Python</sub> |  |
|  [kth_to_last](python/codinginterview/kth_to_last.py) <br><sub>Python</sub> | Get all nodes from kth position to the end |
|  [sum_of_nodes_of_linked_list](python/codinginterview/sum_of_nodes_of_linked_list.py) <br><sub>Python</sub> | Sum value of nodes<br>7 -> 1 -> 6 + 5 -> 9 -> 2 = 617+295 = 2 -> 1 -> 9 |
|  [forward_sum_of_nodes_of_linked_list](python/codinginterview/forward_sum_of_nodes_of_linked_list.py) <br><sub>Python</sub> | (6 -> 1 -> 7) + (2 -> 9). That is 617 + 029 = 6 -> 4 -> 6 |
|  [find_intersection_between_two_linked_list](python/codinginterview/find_intersection_between_two_linked_list.py) <br><sub>Python</sub> | Find intersection between two linked list |
|  [zero_matrix](python/codinginterview/zero_matrix.py) <br><sub>Python</sub> | Make INPLACE row and column of a matrix 0 iff that row contains a 0 |
|  [one_or_zero_edits_away](python/codinginterview/one_or_zero_edits_away.py) <br><sub>Python</sub> |  |
|  [node](python/codinginterview/shared/node.py) <br><sub>Python</sub> |  |
|  [linked_list](python/codinginterview/shared/linked_list.py) <br><sub>Python</sub> |  |
|  [reversed_linked_list](python/codinginterview/shared/reversed_linked_list.py) <br><sub>Python</sub> |  |
|  [base_linked_list](python/codinginterview/shared/base_linked_list.py) <br><sub>Python</sub> |  |
|  [circular_linked_list](python/codinginterview/shared/circular_linked_list.py) <br><sub>Python</sub> |  |

 
 #### References
 
 The questions were taken from these books:
 
 * The Algorithm Design Manual by Steven Skiena
 * Algorithms in a Nutshell by George T. Heineman
 * Cracking the Coding Interview by Gayle Laakmann
 
 The source of idea/algorithm/code are referenced in the code comments.
 
 ___
 <sub>This README was auto-generated during pre-commit.</sub>
