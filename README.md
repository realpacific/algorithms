
# algorithms :robot:

A collection of solution to the data structure and algorithm problems

[View web version](https://prashantbarahi.com.np/docs/algorithms/intro) | [View by tags](https://prashantbarahi.com.np/docs/tags/) 

### Table of Contents

| Filename | Description |
|  --- | --- |
|  [GenerateSubsets](src/handbook/GenerateSubsets.kt) <br><sub>Kotlin &#8226; handbook</sub> | <sup>Bit method – Each subset of n elements can be represented as sequences of n bits <br/>Backtrack method</sup> |
|  [UniquePathsII](src/questions/UniquePathsII.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and space is marked as 1 and 0 respectively in the grid. <br> <img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" height="200" width="200"/> <br> [Source](https://leetcode.com/problems/unique-paths-ii/)</sup> |
|  [SingleElementInSortedArray](src/questions/SingleElementInSortedArray.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Return the single element that appears only once. Your solution must run in `O(log n)` time and `O(1)` space. <br> [Source](https://leetcode.com/problems/single-element-in-a-sorted-array/)</sup> |
|  [UniquePaths](src/questions/UniquePaths.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>A robot is located in the top-left corner of a `m x n` grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). <br> <img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" height="150" width="350"/> <br> How many possible unique paths are there? <br> [Source](https://leetcode.com/problems/unique-paths/)</sup> |
|  [RotateImage](src/questions/RotateImage.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise). <br> [Source](https://leetcode.com/problems/rotate-image-/)</sup> |
|  [LargestDivisibleSubset](src/questions/LargestDivisibleSubset.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a set of distinct positive integers nums, return the largest subset answer such that every pair (`answer[i]`, `answer[j]`) of elements in this subset satisfies: <br> `answer[i] % answer[j] == 0`, or `answer[j] % answer[i] == 0` If there are multiple solutions, return any of them. <br> [Source](https://leetcode.com/problems/largest-divisible-subset/) <br> @see LongestIncreasingSubSeq <br> @see LengthOfLongestIncreasingSubSeq</sup> |
|  [LongestIncreasingSubSeq](src/questions/LongestIncreasingSubSeq.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer array nums, return the longest strictly increasing subsequence. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. <br> [Explanation](https://youtu.be/mouCn3CFpgg?t=1057) <br> @see LengthOfLongestIncreasingSubSeq</sup> |
|  [LengthOfLongestIncreasingSubSeq](src/questions/LengthOfLongestIncreasingSubSeq.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer array nums, return the length of the longest strictly increasing subsequence. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. <br> [Source](https://leetcode.com/problems/longest-increasing-subsequence/) | [Explanation](https://www.youtube.com/watch?v=mouCn3CFpgg) <br> @see LongestIncreasingSubSeq</sup> |
|  [PivotIndex](src/questions/PivotIndex.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Calculate the pivot index of this array. The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right. Return the leftmost pivot index. If no such index exists, return -1. [Source](https://leetcode.com/problems/pivot-index/)</sup> |
|  [IteratorForCombination](src/questions/IteratorForCombination.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Design the CombinationIterator class: <br> <br>* CombinationIterator(string characters, int combinationLength) Initializes the object with a string characters of sorted distinct lowercase English letters and a number combinationLength as arguments. <br>* next() Returns the next combination of length combinationLength in lexicographical order. <br>* hasNext() Returns true if and only if there exists a next combination. <br> [Source](https://leetcode.com/problems/iterator-for-combination/)</sup> |
|  [BuddyString](src/questions/BuddyString.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false. <br> [Source](https://leetcode.com/problems/buddy-strings/)</sup> |
|  [DegreeOfAnArray](src/questions/DegreeOfAnArray.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums. <br> [Source](https://leetcode.com/problems/degree-of-an-array/)</sup> |
|  [DailyTemperatures](src/questions/DailyTemperatures.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an array of integers `temperatures` represents the daily temperatures, return an array answer such that `answer[i]` is the number of days you have to wait after the `ith` day to get a warmer temperature. If there is no future day for which this is possible, keep `answer[i] == 0` instead. <br> [Source](https://leetcode.com/problems/daily-temperatures/)</sup> |
|  [CanPlaceFlowers](src/questions/CanPlaceFlowers.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots. Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule. <br> [Source](https://leetcode.com/problems/can-place-flowers/)</sup> |
|  [DesignSkipList](src/questions/DesignSkipList.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup><img src="https://assets.leetcode.com/uploads/2019/09/27/1506_skiplist.gif" height="200" width="800"/> <br> [Source](https://leetcode.com/problems/design-skiplist/) – [Gist](https://www.youtube.com/watch?v=UGaOXaXAM5M)</sup> |
|  [DesignHashMap](src/questions/DesignHashMap.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Design a HashMap without using any built-in hash table libraries: <br>* `MyHashMap()` initializes the object with an empty map. <br>* `void put(int key, int value)` inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value. <br>* `int get(int key)` returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key. <br>* `void remove(key)` removes the key and its corresponding value if the map contains the mapping for the key. <br> [Source](https://leetcode.com/problems/design-hashmap/) <br> @see MyHashSet</sup> |
|  [DesignHashset](src/questions/DesignHashset.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Implement MyHashSet class: <br>* `void add(key)` Inserts the value key into the HashSet. <br>* `bool contains(key)` Returns whether the value key exists in the HashSet or not. <br>* `void remove(key)` Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing. <br> [Source](https://leetcode.com/problems/design-hashset/) <br> @see MyHashMap</sup> |
|  [ReshapeTheMatrix](src/questions/ReshapeTheMatrix.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>You are given an `m x n` matrix `mat` and two integers `r` and `c` representing the number of rows and the number of columns of the wanted reshaped matrix. The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were. <br> If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. <br> [Source](https://leetcode.com/problems/reshape-the-matrix/)</sup> |
|  [NumberOf1Bits](src/questions/NumberOf1Bits.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight). [Source](https://leetcode.com/problems/number-of-1-bits/)</sup> |
|  [SymmetricTree](src/questions/SymmetricTree.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). <br> [Source](https://leetcode.com/problems/symmetric-tree/)</sup> |
|  [LinkedListCycle](src/questions/LinkedListCycle.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter. <br> Return true if there is a cycle in the linked list. Otherwise, return false. <br> [Source](https://leetcode.com/problems/linked-list-cycle-kt/)</sup> |
|  [ReverseStringII](src/questions/ReverseStringII.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a string `s` and an integer `k`, reverse the first `k` characters for every `2k` characters counting from the start of the string. <br> If there are fewer than `k` characters left, reverse all of them. If there are less than `2k` but greater than or equal to `k` characters, then reverse the first `k` characters and left the other as original. <br> [Source](https://leetcode.com/problems/reverse-string-ii/)</sup> |
|  [LongestAbsoluteFilePath](src/questions/LongestAbsoluteFilePath.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Suppose we have a file system that stores both files and directories. <br> <img src="https://assets.leetcode.com/uploads/2020/08/28/mdir.jpg" height="150" width="150"/> Every file and directory has a unique absolute path in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by '/'s. <br> Given a string input representing the file system in the explained format, return the length of the longest absolute path to a file in the abstracted file system. If there is no file in the system, return 0. <br> [Source](https://leetcode.com/problems/longest-absolute-file-path/)</sup> |
|  [ArrangingCoins](src/questions/ArrangingCoins.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>You have `n` coins and you want to build a staircase with these coins. The staircase consists of `k` rows where the `i`th row has exactly `i` coins. The last row of the staircase may be incomplete. Given the integer n, return the number of complete rows of the staircase you will build. <br> [Source](https://leetcode.com/problems/arranging-coins/)</sup> |
|  [SimplifiedFraction](src/questions/SimplifiedFraction.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer n, return a list of all simplified fractions between 0 and 1 (exclusive) such that the denominator is less-than-or-equal-to n. The fractions can be in any order. <br> [Source](https://leetcode.com/problems/simplified-fractions/)</sup> |
|  [ConvertToHex](src/questions/ConvertToHex.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer num, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used. All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself. [Source](https://leetcode.com/problems/convert-a-number-to-hexadecimal/) – [solution](https://leetcode.com/problems/convert-a-number-to-hexadecimal/discuss/824192/Java-100-Time-with-Detailed-Explanation)</sup> |
|  [SumRootToLeafNumber](src/questions/SumRootToLeafNumber.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup> You are given the root of a binary tree containing digits from 0 to 9 only. Each root-to-leaf path in the tree represents a number. For example, the root-to-leaf path `1 -> 2 -> 3` represents the number 123. Return the total sum of all root-to-leaf numbers. <br> [Source](https://leetcode.com/problems/sum-root-to-leaf-numbers/)</sup> |
|  [FindDuplicateNumber](src/questions/FindDuplicateNumber.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an array of integers nums containing `n + 1` integers where each integer is in the range `[1, n]` inclusive. There is only one repeated number in `nums`, return this repeated number. You must solve the problem without modifying the array nums and uses only constant extra space. <br> [Source](https://leetcode.com/problems/find-the-duplicate-number/)</sup> |
|  [Sqrtx](src/questions/Sqrtx.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a non-negative integer x, compute and return the square root of x. [Source](https://leetcode.com/problems/sqrtx/)</sup> |
|  [SetMismatch](src/questions/SetMismatch.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number. Find the number that occurs twice and the number that is missing and return them in the form of an array. [Source](https://leetcode.com/problems/set-mismatch/)</sup> |
|  [IntersectionOfTwoArrays](src/questions/IntersectionOfTwoArrays.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order. <br> [Source](https://leetcode.com/problems/intersection-of-two-arrays/)</sup> |
|  [ReverseWordsInStringIII](src/questions/ReverseWordsInStringIII.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. <br> [Source](https://leetcode.com/problems/reverse-words-in-a-string-iii/)</sup> |
|  [SurroundedRegions](src/questions/SurroundedRegions.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an `m x n` matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region. <br> [Source](https://leetcode.com/problems/surrounded-regions/)</sup> |
|  [DiameterOfBinaryTree](src/questions/DiameterOfBinaryTree.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. <br> [Source](https://leetcode.com/problems/diameter-of-binary-tree/) – [solution](https://leetcode.com/problems/diameter-of-binary-tree/discuss/101132/Java-Solution-MaxDepth)</sup> |
|  [SumOfLeftLeaves](src/questions/SumOfLeftLeaves.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given the root of a binary tree, return the sum of all left leaves. <br> [Source](https://leetcode.com/problems/sum-of-left-leaves/)</sup> |
|  [CountingBits](src/questions/CountingBits.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer `n`, return an array `ans` of length `n + 1` such that for each `i` (0 <= i <= n), `ans[i]` is the number of 1's in the binary representation of `i`. <br> [Source](https://leetcode.com/problems/counting-bits/)</sup> |
|  [WildcardSearchDS](src/questions/WildcardSearchDS.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Design a data structure that supports adding new words and finding if a string matches any previously added string. Your data structure should implement two methods <br>* `addWord(word)`- Adds word to the data structure <br>* `searchWorld(word)`- Returns true if there is any string in the data structure that matches word. Word may contain dots where a dot can be matched with any letter (a dot represents a wildcard).</sup> |
|  [NimGame](src/questions/NimGame.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>You are playing the following Nim Game with your friend: <br> <br>* Initially, there is a heap of stones on the table. <br>* You and your friend will alternate taking turns, and you go first. <br>* On each turn, the person whose turn it is will remove 1 to 3 stones from the heap. <br>* The one who removes the last stone is the winner. <br> Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false. <br> [Source](https://leetcode.com/problems/nim-game/)  – [Solution](https://leetcode.com/problems/nim-game/discuss/73749/Theorem:-all-4s-shall-be-false)</sup> |
|  [ContainsDuplicateII](src/questions/ContainsDuplicateII.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that `nums[i] == nums[j]` and `abs(i - j) <= k`. <br> [Source](https://leetcode.com/problems/contains-duplicate-ii/)</sup> |
|  [ExcelSheetColumnTitle](src/questions/ExcelSheetColumnTitle.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet. `A -> 1, B -> 2, C -> 3, Z -> 26, AA -> 27, AB -> 28` <br> [Source](https://leetcode.com/problems/excel-sheet-column-title/)</sup> |
|  [ReverseBits](src/questions/ReverseBits.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Reverse bits of a given 32 bits unsigned integer. [Source](https://leetcode.com/problems/reverse-bits/) – [Solution](https://leetcode.com/problems/reverse-bits/discuss/54746/Java-Solution-and-Optimization)</sup> |
|  [MinStack](src/questions/MinStack.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. [Source](https://leetcode.com/problems/min-stack/)</sup> |
|  [longest_palindrome](python/longest_palindrome.py) <br><sub>Python &#8226; python</sub> | <sup></sup> |
|  [RepeatedSubstringPattern](src/questions/RepeatedSubstringPattern.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. [Source](https://leetcode.com/problems/repeated-substring-pattern/) - [Solution](https://leetcode.com/problems/repeated-substring-pattern/discuss/94334/Easy-python-solution-with-explaination)</sup> |
|  [CountCompleteTreeNode](src/questions/CountCompleteTreeNode.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given the root of a complete binary tree, return the number of the nodes in the tree. Every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. [Source](https://leetcode.com/problems/count-complete-tree-nodes/)</sup> |
|  [AddBinary](src/questions/AddBinary.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given two binary strings a and b, return their sum as a binary string. [Source](https://leetcode.com/problems/add-binary/)</sup> |
|  [BestTimeStockII](src/questions/BestTimeStockII.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>You are given an integer array prices where `prices[i]` is the price of a given stock on the ith day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve. <br> [Source](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/) <br> @see [BestTimeStock]</sup> |
|  [IsSubsequence](src/questions/IsSubsequence.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given two strings s and t, return true if s is a subsequence of t, or false otherwise. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. [Source](https://leetcode.com/problems/is-subsequence/)</sup> |
|  [BestTimeStock](src/questions/BestTimeStock.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>You are given an array prices where `prices[i]` is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. <br> [Source](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) @see [BestTimeStockII]</sup> |
|  [TotalHammingDistance](src/questions/TotalHammingDistance.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given an integer array nums, return the sum of Hamming distances between all the pairs of the integers in nums. [Source](https://leetcode.com/problems/total-hamming-distance/)</sup> |
|  [HammingDistance](src/questions/HammingDistance.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, return the Hamming distance between them. [Source](https://leetcode.com/problems/hamming-distance/)</sup> |
|  [MaxAreaOfIsland](src/questions/MaxAreaOfIsland.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Return the maximum area of an island in grid. If there is no island, return 0. <img src="https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg" height="150" width="150"/> [Source](https://leetcode.com/problems/max-area-of-island)</sup> |
|  [MinIndexOfSumLists](src/questions/MinIndexOfSumLists.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings. You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer. [Source](https://leetcode.com/problems/minimum-index-sum-of-two-lists/)</sup> |
|  [MoveZeroes](src/questions/MoveZeroes.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements. [Source](https://leetcode.com/problems/move-zeroes/)</sup> |
|  [MissingNumber](src/questions/MissingNumber.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. [Source](https://leetcode.com/problems/missing-number/)</sup> |
|  [ArrayPartitionI](src/questions/ArrayPartitionI.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum. [Source](https://leetcode.com/problems/array-partition-i/)</sup> |
|  [IslandPerimeter](src/questions/IslandPerimeter.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have "lakes", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. <br> <img src="https://assets.leetcode.com/uploads/2018/10/12/island.png" height="150" width="150"/> Determine the perimeter of the island. <br> [Source](https://leetcode.com/problems/island-perimeter/)</sup> |
|  [MaxSubarray](src/questions/MaxSubarray.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. [Source](https://leetcode.com/problems/maximum-subarray/) – [Solution](https://leetcode.com/problems/maximum-subarray/discuss/20396/Easy-Python-Way)</sup> |
|  [MaxProductSubArray](src/questions/MaxProductSubArray.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product. [Source](https://leetcode.com/problems/maximum-product-subarray/) – [Solution](https://leetcode.com/problems/maximum-product-subarray/discuss/48302/2-Passes-scan-beats-99)</sup> |
|  [MergeSortedLists](src/questions/MergeSortedLists.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists. [Source](https://leetcode.com/problems/merge-two-sorted-lists/)</sup> |
|  [KeyboardRow](src/questions/KeyboardRow.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an array of strings words, return the words that can be typed using letters of the alphabet on only one row of American keyboard. [Source](https://leetcode.com/problems/keyboard-row/)</sup> |
|  [SwapAdjacentNodes](src/questions/SwapAdjacentNodes.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a linked list, swap every two adjacent nodes and return its head. <br> 1 -> 2 -> 3 -> 4 -----> 2 -> 1 -> 4 -> 3</sup> |
|  [RandomizedSet](src/questions/RandomizedSet.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Implement the RandomizedSet class: <br>* `RandomizedSet()` Initializes the RandomizedSet object. <br>* `bool insert(int val)` Inserts an item val into the set if not present. Returns true if not present, false otherwise. <br>* `bool remove(int val)` Removes an item val from the set if present. Returns true if the item was present, false otherwise. <br>* `int getRandom()` Returns a random element from the current set of elements. [Source](https://leetcode.com/problems/insert-delete-getrandom-o1/)</sup> |
|  [ClimbingStairs](src/questions/ClimbingStairs.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? [Source](https://leetcode.com/problems/climbing-stairs/)</sup> |
|  [FirstUniqueCharacter](src/questions/FirstUniqueCharacter.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1. [Source](https://leetcode.com/problems/first-unique-character-kt/)</sup> |
|  [TopKFrequent](src/questions/TopKFrequent.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. [Source](https://leetcode.com/problems/top-k-frequent-elements//)</sup> |
|  [ContainsDuplicate](src/questions/ContainsDuplicate.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. [Source](https://leetcode.com/problems/contains-duplicate/)</sup> |
|  [SortCharByFrequency](src/questions/SortCharByFrequency.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup> Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string. Return the sorted string. If there are multiple answers, return any of them. [Source](https://leetcode.com/problems/sort-characters-by-frequency/)</sup> |
|  [RangeSumQuery](src/questions/RangeSumQuery.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer array nums, handle multiple queries of the following type: Calculate the sum of the elements of nums between indices left and right inclusive where left <= right. [Source](https://leetcode.com/problems/range-sum-query-immutable/)</sup> |
|  [RangeSumQueryMutable](src/questions/RangeSumQueryMutable.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer array nums, handle multiple queries of the following types: <br>* Update the value of an element in nums. <br>* Calculate the sum of the elements of nums between indices left and right inclusive where left <= right. <br> [Source](https://leetcode.com/problems/range-sum-query-mutable/)</sup> |
|  [NextGreaterElementII](src/questions/NextGreaterElementII.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums. The next greater number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return -1 for this number. <br> [Source](https://leetcode.com/problems/next-greater-element-ii/)</sup> |
|  [NextGreaterElement](src/questions/NextGreaterElement.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>The next greater element of some element x in an array is the first greater element that is to the right of x in the same array. <br> You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2 and all are unique. <br> For each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1. <br> [Source](https://leetcode.com/problems/next-greater-element-i/)</sup> |
|  [MinDeletionUniqueFrequency](src/questions/MinDeletionUniqueFrequency.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Minimum Deletions to Make Character Frequencies Unique <br> A string s is called good if there are no two different characters in s that have the same frequency. Given a string s, return the minimum number of characters you need to delete to make s good. <br> [Source](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/) – [Solution](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/discuss/1107954/Java-Simple-Solution)</sup> |
|  [PascalTriangleII](src/questions/PascalTriangleII.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle. <br> @see pascalTriangle [Source](https://leetcode.com/problems/pascals-triangle-ii/)</sup> |
|  [PascalTriangle](src/questions/PascalTriangle.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer numRows, return the first numRows of Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it as shown: <br> <img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" height="150" width="150"/> [Source](https://leetcode.com/problems/pascals-triangle/)</sup> |
|  [CousinsBinaryTree](src/questions/CousinsBinaryTree.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given the root of a binary tree with unique values and the values of two different nodes of the tree x and y, return true if the nodes corresponding to the values x and y in the tree are cousins, or false otherwise. <br> Two nodes of a binary tree are cousins if they have the same depth with different parents. <br> [Source](https://leetcode.com/problems/cousins-in-binary-tree/)</sup> |
|  [RansomNote](src/questions/RansomNote.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given two stings ransomNote and magazine, return true if ransomNote can be constructed from magazine and false otherwise. Each letter in magazine can only be used once in ransomNote. <br> [Source](https://leetcode.com/problems/ransom-note-kt/)</sup> |
|  [UglyNumber](src/questions/UglyNumber.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup> An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given an integer n, return true if n is an ugly number. [Source](https://leetcode.com/problems/ugly-number/)</sup> |
|  [RegionsCutBySlashes](src/questions/RegionsCutBySlashes.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>An n x n grid is composed of 1 x 1 squares where each 1 x 1 square consists of a '/', '\', or blank space ' '. These characters divide the square into contiguous regions. Given the grid `grid` represented as a string array, return the number of regions. Note that backslash characters are escaped, so a '\' is represented as '\\'. <br> [Explanation](https://www.youtube.com/watch?v=Wafu5vOxPRE) – [Source](https://leetcode.com/problems/regions-cut-by-slashes/)</sup> |
|  [forward_sum_of_nodes](python/codinginterview/forward_sum_of_nodes.py) <br><sub>Python &#8226; codinginterview</sub> | <sup>(6 -> 1 -> 7) + (2 -> 9). That is 617 + 029 = 6 -> 4 -> 6</sup> |
|  [find_intersection_linked_list](python/codinginterview/find_intersection_linked_list.py) <br><sub>Python &#8226; codinginterview</sub> | <sup>Find intersection between two linked list</sup> |
|  [DetectCapital](src/questions/DetectCapital.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>We define the usage of capitals in a word to be right when one of the following cases holds: <br>* All letters in this word are capitals, like "USA". <br>* All letters in this word are not capitals, like "leetcode". <br>* Only the first letter in this word is capital, like "Google". <br> Given a string word, return true if the usage of capitals in it is right. <br> [Source](https://leetcode.com/problems/detect-capital/)</sup> |
|  [ReverseVowel](src/questions/ReverseVowel.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a string s, reverse only all the vowels in the string and return it. The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both cases. <br> [Source](https://leetcode.com/problems/reverse-vowels-of-a-string/)</sup> |
|  [StackUsingQueues](src/questions/StackUsingQueues.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty). <br> [Source](https://leetcode.com/problems/implement-stack-using-queues/)</sup> |
|  [ReverseString](src/questions/ReverseString.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Write a function that reverses a string. The input string is given as an array of characters s. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. <br> [Source](https://leetcode.com/problems/reverse-string/)</sup> |
|  [FirstBadVersion](src/questions/FirstBadVersion.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. <br> You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. <br>  Constraint `1 <= bad <= n <= 2^31 - 1` <br> [Source](https://leetcode.com/problems/first-bad-version/)</sup> |
|  [ValidAnagram](src/questions/ValidAnagram.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given two strings s and t, return true if t is an anagram of s, and false otherwise. <br> [Source](https://leetcode.com/problems/valid-anagram/)</sup> |
|  [FindAllAnagrams](src/questions/FindAllAnagrams.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order. <br> [Source](https://leetcode.com/problems/find-all-anagrams-in-a-string/)</sup> |
|  [LongestPalindrome](src/questions/LongestPalindrome.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters. <br> Letters are case sensitive, for example, "Aa" is not considered a palindrome here. <br> [Source](https://leetcode.com/problems/longest-palindrome/)</sup> |
|  [SummaryRanges](src/questions/SummaryRanges.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>You are given a sorted unique integer array nums. <br> Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums. <br> Each range [a,b] in the list should be output as: <br>*"a->b" if a != b <br>* "a" if a == b <br> [Source](https://leetcode.com/problems/summary-ranges/)</sup> |
|  [SameTree](src/questions/SameTree.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup> Given the roots of two binary trees p and q, write a function to check if they are the same or not. <br> [Source](https://leetcode.com/problems/same-tree/)</sup> |
|  [BSTFromPreorder](src/questions/BSTFromPreorder.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an array of integers preorder, which represents the preorder traversal of a BST (i.e., binary search tree), construct the tree and return its root. A preorder traversal of a binary tree displays the value of the node first, then traverses `Node.left`, then traverses `Node.right`. <br> [Source](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/)</sup> |
|  [WordPattern](src/questions/WordPattern.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. <br> [Source](https://leetcode.com/problems/word-pattern/)</sup> |
|  [PowerOf4](src/questions/PowerOf4.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer n, return true if it is a power of four. Otherwise, return false. An integer n is a power of four, if there exists an integer x such that n == 4x. <br> [Source](https://leetcode.com/problems/power-of-four)</sup> |
|  [LicenseKeyFormatting](src/questions/LicenseKeyFormatting.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>You are given a license key represented as a string s that consists of only alphanumeric characters and dashes. The string is separated into n + 1 groups by n dashes. You are also given an integer k. We want to reformat the string s such that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase. Return the reformatted license key. <br> [Source](https://leetcode.com/problems/license-key-formatting/)</sup> |
|  [HappyNumber](src/questions/HappyNumber.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Write an algorithm to determine if a number n is happy. A happy number is a number defined by the following process: <br>* Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy. <br> [Source](https://leetcode.com/problems/happy-number)</sup> |
|  [MaxDepthOfBinaryTree](src/questions/MaxDepthOfBinaryTree.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. <br> [Source](https://leetcode.com/problems/maximum-depth-of-binary-tree/)</sup> |
|  [AssignCookies](src/questions/AssignCookies.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. <br> Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number. <br> [Source](https://leetcode.com/problems/assign-cookies/)</sup> |
|  [MajorityElement](src/questions/MajorityElement.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array. <br> [Source](https://leetcode.com/problems/majority-element/)</sup> |
|  [TwoSumII](src/questions/TwoSumII.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Return the indices of the two numbers, index1 and index2, as an integer array [index1, index2] of length 2. <br> The tests are generated such that there is exactly one solution. You may not use the same element twice. <br> [Source](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)</sup> |
|  [AddStrings](src/questions/AddStrings.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string. You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly. <br> [Source](https://leetcode.com/problems/add-strings/)</sup> |
|  [ThirdMaximumNumber](src/questions/ThirdMaximumNumber.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.</sup> |
|  [FindTheDifference](src/questions/FindTheDifference.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>You are given two strings s and t. String t is generated by random shuffling string s and then add one more letter at a random position. Return the letter that was added to t. <br> [Source](https://leetcode.com/problems/find-the-difference/)</sup> |
|  [ValidPalindrome](src/questions/ValidPalindrome.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</sup> |
|  [SingleNumber](src/questions/SingleNumber.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space. <br> [Source](https://leetcode.com/problems/single-number/)</sup> |
|  [IsomorphicStrings](src/questions/IsomorphicStrings.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. <br> All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself. <br> [Source](https://leetcode.com/problems/isomorphic-strings/)</sup> |
|  [SingleNumberII](src/questions/SingleNumberII.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it. <br> [Source](https://leetcode.com/problems/single-number-ii/)</sup> |
|  [SingleNumberIII](src/questions/SingleNumberIII.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order. <br> [Source](https://leetcode.com/problems/single-number-iii/)</sup> |
|  [PathSum](src/questions/PathSum.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.</sup> |
|  [PlusOne](src/questions/PlusOne.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's. Increment the large integer by one and return the resulting array of digits. <br> [Source](https://leetcode.com/problems/plus-one/)</sup> |
|  [RemoveDuplicatesFromSortedList](src/questions/RemoveDuplicatesFromSortedList.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well. <br> [source](https://leetcode.com/problems/remove-duplicates-from-sorted-list/)</sup> |
|  [LengthOfLastWord](src/questions/LengthOfLastWord.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a string s consisting of some words separated by some number of spaces, return the length of the last word in the string. A word is a maximal substring consisting of non-space characters only. <br> [Source](https://leetcode.com/problems/length-of-last-word)</sup> |
|  [RomanToInteger](src/questions/RomanToInteger.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. I = 1, V=5, X = 10, L = 50, C = 100, D = 500, M = 1000 <br> For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II. <br> Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: <br> <br>* I can be placed before V (5) and X (10) to make 4 and 9. <br>* X can be placed before L (50) and C (100) to make 40 and 90. <br>* C can be placed before D (500) and M (1000) to make 400 and 900. <br> Given a roman numeral, convert it to an integer.</sup> |
|  [DivideTwoIntegers](src/questions/DivideTwoIntegers.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero, which means losing its fractional part. For example, truncate(8.345) = 8 and truncate(-2.7335) = -2. <br> Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For this problem, assume that your function returns 2^31 − 1 when the division result overflows. <br> https://leetcode.com/problems/divide-two-integers/</sup> |
|  [ThreeSumClosest](src/questions/ThreeSumClosest.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. <br> [Source](https://leetcode.com/problems/3sum-closest/)</sup> |
|  [LetterCombinationsOfPhoneNumber](src/questions/LetterCombinationsOfPhoneNumber.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. <br> <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" height="150" width="300"/> <br> [Source](https://leetcode.com/problems/letter-combinations-of-a-phone-number/) <br></sup> |
|  [MergeTwoSortedList](src/questions/MergeTwoSortedList.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.</sup> |
|  [MaxNumberOfBalloons](src/questions/MaxNumberOfBalloons.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a string text, you want to use the characters of text to form as many instances of the word "balloon" as possible. You can use each character in text at most once. Return the maximum number of instances that can be formed. <br> Input: text = "nlaebolko"; Output: 1 <br> [Source](https://leetcode.com/explore/item/3973)</sup> |
|  [ContainerWithMostWater](src/questions/ContainerWithMostWater.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water. <img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" height="150" width="300"/> [Source](https://leetcode.com/problems/container-with-most-water/)</sup> |
|  [ZigZagConversion](src/questions/ZigZagConversion.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: P   A   H   N A P L S I I G Y   I   R And then read line by line: "PAHNAPLSIIGYIR" [Source](https://leetcode.com/problems/zigzag-conversion/)</sup> |
|  [LongestCommonPrefix](src/questions/LongestCommonPrefix.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string "".</sup> |
|  [SearchInsertPosition](src/questions/SearchInsertPosition.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity. <br> [Source](https://leetcode.com/problems/search-insert-position/)</sup> |
|  [RemoveDuplicateFromSortedArray](src/questions/RemoveDuplicateFromSortedArray.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place. The relative order of the elements should be kept the same. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums. <br> [Source](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/)</sup> |
|  [BreadthFirstTraversal](src/algorithmdesignmanualbook/graph/BreadthFirstTraversal.kt) <br><sub>Kotlin &#8226; graph</sub> | <sup></sup> |
|  [FindTransitionIndex](src/algorithmdesignmanualbook/sorting/FindTransitionIndex.kt) <br><sub>Kotlin &#8226; sorting</sub> | <sup>Given unbounded 0s followed by unbounded number of 1s, find the first index of transition. <br> Done using ONE-SIDED BINARY SEARCH <br> Solution: <br> Incremental search 1,2,4,6,8... and then binary search on transition range</sup> |
|  [FindNumberOfOccurrence](src/algorithmdesignmanualbook/sorting/FindNumberOfOccurrence.kt) <br><sub>Kotlin &#8226; sorting</sub> | <sup>Find the range in which [str] occurs in [array]. <br> [Solution here](https://tutorialspoint.dev/algorithm/searching-algorithms/count-number-of-occurrences-or-frequency-in-a-sorted-array)</sup> |
|  [ArrangeNegativeThenPositiveNumber](src/algorithmdesignmanualbook/sorting/ArrangeNegativeThenPositiveNumber.kt) <br><sub>Kotlin &#8226; sorting</sub> | <sup>4-20 Rearrange an array of n keys so that all the negative keys precede all the nonnegative keys</sup> |
|  [FastMedian](src/algorithmdesignmanualbook/sorting/FastMedian.kt) <br><sub>Kotlin &#8226; sorting</sub> | <sup>NO need to sort all the items. Just find the sort the items before the median index Using quicksort, find the partition. Then throw away the left partition if the median index lies in the right portion while calibrating the new median index. <br> Similar to finding the kth smallest item in the unsorted list</sup> |
|  [is_linked_list_circular](python/codinginterview/is_linked_list_circular.py) <br><sub>Python &#8226; codinginterview</sub> | <sup>Detect if a Linked List is circular</sup> |
|  [one_or_zero_edits_away](python/codinginterview/one_or_zero_edits_away.py) <br><sub>Python &#8226; codinginterview</sub> | <sup>199. One Away: There are three types of edits that can be performed on strings: insert a character, remove a character, or replace a character. Given two strings, write a function to check if they are one edit(or zero edits) away.</sup> |
|  [is_palindrome_permutation](python/codinginterview/is_palindrome_permutation.py) <br><sub>Python &#8226; codinginterview</sub> | <sup>195. Palindrome Permutation: Given a string, write a function to check if it is a permutation of a palindrome.</sup> |
|  [is_linked_list_palindrome](python/codinginterview/is_linked_list_palindrome.py) <br><sub>Python &#8226; codinginterview</sub> | <sup>Check if a linked list is a palindrome</sup> |
|  [sum_of_nodes_of_linked_list](python/codinginterview/sum_of_nodes_of_linked_list.py) <br><sub>Python &#8226; codinginterview</sub> | <sup>Sum value of nodes 7 -> 1 -> 6 + 5 -> 9 -> 2 = 617+295 = 2 -> 1 -> 9</sup> |
|  [KDTree](src/algorithmsinanutshell/spatialtree/KDTree.kt) <br><sub>Kotlin &#8226; spatialtree</sub> | <sup>K-d tree is a binary search tree with more than 1 dimensions (i.e k dimensions). <br> A 2-d tree looks like given points ((3, 6), (17, 15), (13, 15), (6, 12), (9, 1), (2, 7), (10, 19)) <br>  (3, 6)   ----> compare x coordinate /       \ (2,7)          (17, 15)     ----y  compare y /     \ (6,12)        (13,15)         ----x compare x \        / (9,1)  (10,19)        ----y <br> At each level, the dimensions of points are compared in alternating manner. <br></sup> |
|  [KnapSack01](src/algorithmsinanutshell/spatialtree/KnapSack01.kt) <br><sub>Kotlin &#8226; spatialtree</sub> | <sup>Knapsack Problem: Given total capacity [totalCapacity] of a bag, how can you select subset of items of weight [weights] with profit [profits] such that the profit is maximized? <br> [Video](https://www.youtube.com/watch?v=8LusJS5-AGo) <br> <br>! P ! w ! 0 ! 1 ! 2 ! 3 ! 4 ! 5 ! 6 ! 7 ! <br>! 1 ! 1 !   !   !   !   !   !   !   !   ! <br>! 4 ! 3 !   !   !   !   !   !   !   !   ! <-- while here, everything below are ignored so w1 and w3 are considered <br>! 5 ! 4 !   !   !   !   !   !   !   !   ! <br>! 6 ! 5 !   !   !   !   !   !   !   !   ! <br></sup> |
|  [NearestNeighbourQueries](src/algorithmsinanutshell/spatialtree/NearestNeighbourQueries.kt) <br><sub>Kotlin &#8226; spatialtree</sub> | <sup>Given a target T and a set of points S, find the nearest neighbour of T in S. <br> https://www.youtube.com/watch?v=Glp7THUpGow <br> https://www.youtube.com/watch?v=XG4zpiJAkD4 <br> https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/kdtrees.pdf</sup> |
|  [QuadTree](src/algorithmsinanutshell/spatialtree/QuadTree.kt) <br><sub>Kotlin &#8226; spatialtree</sub> | <sup>https://algs4.cs.princeton.edu/92search/QuadTree.java.html <br> https://www.youtube.com/watch?v=jxbDYxm-pXg <br> https://www.youtube.com/watch?v=xFcQaig5Z2A</sup> |
|  [IntersectionOfLines](src/algorithmsinanutshell/IntersectionOfLines.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | <sup>Two lines (P1, P2) and (P3,P4) intersect when orientation of: <br>* (P1 wrt P3,P4) and (P2 wrt P3,P4) <br>* (P3 wrt P1,P2) and (P4 wrt P1,P2) <br> are different. <br> A line (P1, P2) can be represented as vector P1P2 and orientation is the way (whether counter-clockwise or clockwise) direction it makes fromTo move from P1P2 fromTo P3. <br> P3 o <br> P1 o----->---o P2 <br> orientation of P3 wrt P1P2 is ACW. <br> Special case is when (P1, P2) and (P3,P4) are collinear. <br> <br>* In case of non-intersecting case, orientation is 0 for both P3(P1P2) and P4(P1,P2) and vv. <br> P1 o----->---o P2   P3 o----->---o P4  (Non-intersecting case) <br> <br>* In case of intersecting case, orientation is different for both P3(P1P2) and P4(P1,P2) and vv. <br> P1 o----->--oP3-----P2o-->---o P4 (Intersecting case) <br>   [Link](https://www.youtube.com/watch?v=bbTqI0oqL5U)</sup> |
|  [ConvexHullScanUsingGrahamScan](src/algorithmsinanutshell/ConvexHullScanUsingGrahamScan.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | <sup>Find Convex Hull - a polygon that surrounds all points <br> [link](https://www.cs.auckland.ac.nz/software/AlgAnim/convex_hull.html)</sup> |
|  [OrientationOf3Points](src/algorithmsinanutshell/OrientationOf3Points.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | <sup>[Link](https://www.geeksforgeeks.org/orientation-3-ordered-points/) <br> [Related](https://youtu.be/bbTqI0oqL5U?t=161)</sup> |
|  [LineSweepAlgorithm](src/algorithmsinanutshell/LineSweepAlgorithm.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | <sup>Given a number of lines, find the lines that intersects with each other <br> Starting from left, sweep a vertical line through each point. Find the intersection of lines with each other that the vertical lines touches. If the sweep line has moved past a line (both points are to its left), this can be ignored. <br> [link](https://www.geeksforgeeks.org/given-a-set-of-line-segments-find-if-any-two-segments-intersect/)</sup> |
|  [Network](src/algorithmsinanutshell/networkflow/Network.kt) <br><sub>Kotlin &#8226; networkflow</sub> | <sup></sup> |
|  [FordFulkersonAlgorithm](src/algorithmsinanutshell/networkflow/FordFulkersonAlgorithm.kt) <br><sub>Kotlin &#8226; networkflow</sub> | <sup>Algorithm to find the max flow to the sink in a given [network] <br> https://brilliant.org/wiki/ford-fulkerson-algorithm/ <br> https://www.youtube.com/watch?v=NwenwITjMys <br> O(E*mf) where E=edge, mf=value of max flow</sup> |
|  [FloydWarshallAlgorithm](src/algorithmsinanutshell/FloydWarshallAlgorithm.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | <sup># All pair shortest path algorithm <br> While Dijkstra Shortest Path algorithm helps find shortest path between start and end vertex, [FloydWarshallAlgorithm] finds the shortest path between all vertices in a [graph] <br> [Source](https://www.youtube.com/watch?v=oNI0rf2P9gE)</sup> |
|  [PrimMinSpanningTreeAlgorithm](src/algorithmsinanutshell/PrimMinSpanningTreeAlgorithm.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | <sup>Prim Algorithm starts from min cost edge and then selects the next small cost edge while maintaining the connection with first edge. <br> This can be modeled using [PriorityQueue] sorted using [Edge] w.r.t its weight</sup> |
|  [TreeTraversal](src/algorithmsinanutshell/TreeTraversal.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | <sup></sup> |
|  [GraphTraversal](src/algorithmsinanutshell/GraphTraversal.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | <sup>Depth First Traversal <br/>Breadth First Traversal</sup> |
|  [DijkstraAlgorithm](src/algorithmsinanutshell/DijkstraAlgorithm.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | <sup></sup> |
|  [Graph](src/algorithmsinanutshell/Graph.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | <sup></sup> |
|  [GreatestCommonDivisor](src/algorithmsinanutshell/GreatestCommonDivisor.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | <sup>Greatest common divisor using Euclidean Algorithm <br> [Link](https://www.freecodecamp.org/news/euclidian-gcd-algorithm-greatest-common-divisor/)</sup> |
|  [AVLTree](src/algorithmsinanutshell/AVLTree.kt) <br><sub>Kotlin &#8226; algorithmsinanutshell</sub> | <sup>Always a balanced tree https://www.youtube.com/watch?v=jDM6_TnYIqE <br> To delete a non-leaf/non-root node, remove it and find the right most descendant and put it there. The child of right most descendant will replace the old position of rightmost descendant <br> Since there are fixed number of rotation, it can be considered as O(1) <br> Other variations of tree are <br>* n-way tree like B-trees <br>* red-black tree with more relaxed rotation rules and enforces height of one branch isn't greater than 2x other branch</sup> |
|  [BucketSort](src/algorithmdesignmanualbook/sorting/BucketSort.kt) <br><sub>Kotlin &#8226; sorting</sub> | <sup>Maintains bucket of 0..9 or a-z The number of iterations requires depends on number of characters in longest element (length wise) <br> [Algorithm](https://www.youtube.com/watch?v=JMlYkE8hGJM)</sup> |
|  [Permutation](src/algorithmdesignmanualbook/heuristics/backtrack/Permutation.kt) <br><sub>Kotlin &#8226; backtrack</sub> | <sup></sup> |
|  [AllSubsets](src/algorithmdesignmanualbook/heuristics/backtrack/AllSubsets.kt) <br><sub>Kotlin &#8226; backtrack</sub> | <sup></sup> |
|  [MinDifferenceBetweenSubsets](src/algorithmdesignmanualbook/dynamic/MinDifferenceBetweenSubsets.kt) <br><sub>Kotlin &#8226; dynamic</sub> | <sup></sup> |
|  [EditDistance](src/algorithmdesignmanualbook/dynamic/EditDistance.kt) <br><sub>Kotlin &#8226; dynamic</sub> | <sup></sup> |
|  [UnionFind](src/algorithmdesignmanualbook/graph/UnionFind.kt) <br><sub>Kotlin &#8226; graph</sub> | <sup>Union-Find represent each subset as backward trees <br>!  0  !  1  !  2  ! <br>!  1  !  2  !  0  ! <br> [Video1](https://www.youtube.com/watch?v=ayW5B2W9hfo) - [Video2](https://www.youtube.com/watch?v=eTaWFhPXPz4) - [Solution](https://www.geeksforgeeks.org/union-find/)</sup> |
|  [PrimMinSpanningTree](src/algorithmdesignmanualbook/graph/PrimMinSpanningTree.kt) <br><sub>Kotlin &#8226; graph</sub> | <sup>Solution: https://www.programiz.com/dsa/prim-algorithm <br> Given vertices with weighted edges, from start vertex, chose the edge with min edge such that it doesnt form cycle.</sup> |
|  [SimpleGraph](src/algorithmdesignmanualbook/graph/SimpleGraph.kt) <br><sub>Kotlin &#8226; graph</sub> | <sup></sup> |
|  [Graph](src/algorithmdesignmanualbook/graph/Graph.kt) <br><sub>Kotlin &#8226; graph</sub> | <sup></sup> |
|  [SmallestMissingNumber](src/algorithmdesignmanualbook/searching/SmallestMissingNumber.kt) <br><sub>Kotlin &#8226; searching</sub> | <sup>[4-34] Suppose that you are given a sorted sequence of distinct integers {a1, a2, . . . , an}, drawn from 1 to m where n < m. Give an O(lg n) algorithm to find an integer ≤ m that is not present in a. For full credit, find the smallest such integer. <br> Solution: Binary search into the array. Since its sorted and starts from index 1, every element at index i should have element i. <br></sup> |
|  [MagicIndexSearch](src/algorithmdesignmanualbook/searching/MagicIndexSearch.kt) <br><sub>Kotlin &#8226; searching</sub> | <sup>[4-33] Algorithm to determine whether there exists an i index such as ai = i given array of {a1, a2, a3 ... an} Sorted and distinct case:</sup> |
|  [ColorSortLinearTime](src/algorithmdesignmanualbook/sorting/ColorSortLinearTime.kt) <br><sub>Kotlin &#8226; sorting</sub> | <sup>Suppose an array A consists of n elements, each of which is red, white, or blue. We seek to sort the elements so that all the reds come before all the whites, which come before all the blues The only operation permitted on the keys are: examine and swap.</sup> |
|  [KSum](src/algorithmdesignmanualbook/sorting/KSum.kt) <br><sub>Kotlin &#8226; sorting</sub> | <sup>Given a set S of n integers and an integer T, give an algorithm to test whether k of the integers in S add up to T. <br> [Another way](https://www.geeksforgeeks.org/find-the-k-th-permutation-sequence-of-first-n-natural-numbers/) <br> ### IDEA: <br> For target=21, k=3 i.e. 21/3 and array: <br> <br>! 5 ! 6 ! 8 ! 10 ! 12 ! <br> <------- 21/3 ------> <br> ^ <---   16/2    ---> <br> ^ <---  10/1 ---></sup> |
|  [KSortedListMerge](src/algorithmdesignmanualbook/sorting/KSortedListMerge.kt) <br><sub>Kotlin &#8226; sorting</sub> | <sup>Give an O(n log k)-time algorithm that merges k sorted lists with a total of n elements into one sorted list. (Hint: use a heap to speed up the elementary O(kn)-time algorithm).</sup> |
|  [TwoPairSum](src/algorithmdesignmanualbook/sorting/TwoPairSum.kt) <br><sub>Kotlin &#8226; sorting</sub> | <sup>O(nlogn) algorithm for finding whether there exists a pair of elements, one from S1 and one from S2, that add up to x</sup> |
|  [ColorSort](src/algorithmdesignmanualbook/sorting/ColorSort.kt) <br><sub>Kotlin &#8226; sorting</sub> | <sup>Assume that we are given n pairs of items as input, where the first item is a number and the second item is one of three colors (red, blue, or yellow). Further assume that the items are sorted by number. Give an O(n) algorithm to sort the items by color (all reds before all blues before all yellows) such that the numbers for identical colors stay sorted. <br> Solution: Maintain 3 queue for each color. At last, dequeue red, blue and then yellow</sup> |
|  [DynamicGrowShrinkArray](src/algorithmdesignmanualbook/datastructures/DynamicGrowShrinkArray.java) <br><sub>Java &#8226; datastructures</sub> | <sup></sup> |
|  [CutoutsToGenerateString](src/algorithmdesignmanualbook/datastructures/CutoutsToGenerateString.kt) <br><sub>Kotlin &#8226; datastructures</sub> | <sup>You are given a search string and a magazine. You seek to generate all the characters in search string by cutting them out from the magazine. Give an algorithm to efficiently determine whether the magazine contains all the letters in the search string <br> Notes: <br>* Cases matters <br>* Whitespace doesn't matter</sup> |
|  [LargestOccuringOrderedPair](src/algorithmdesignmanualbook/datastructures/LargestOccuringOrderedPair.kt) <br><sub>Kotlin &#8226; datastructures</sub> | <sup></sup> |
|  [Node](src/algorithmdesignmanualbook/datastructures/Node.kt) <br><sub>Kotlin &#8226; datastructures</sub> | <sup></sup> |
|  [IdenticalBinaryTree](src/algorithmdesignmanualbook/datastructures/IdenticalBinaryTree.kt) <br><sub>Kotlin &#8226; datastructures</sub> | <sup>Given two binary tree, find if they are identical i.e. same value at the same position & same structure</sup> |
|  [SmallestNumberInRange](src/algorithmdesignmanualbook/datastructures/SmallestNumberInRange.kt) <br><sub>Kotlin &#8226; datastructures</sub> | <sup> Suppose that we are given a sequence of n values x1, x2, ..., xn and seek to quickly answer repeated queries of the form: given i and j, find the smallest value in xi, . . . , xj. <br> Given arrays of integer [values] of size n, convert it into matrix M of nxn such that M[i][j + 1] <= M[i][j] and anything before M[i][i] is null. M[i][i] holds the ith index item of [values]</sup> |
|  [NoInitializationArray](src/algorithmdesignmanualbook/datastructures/NoInitializationArray.kt) <br><sub>Kotlin &#8226; datastructures</sub> | <sup>Design a data structure that allows one to search, insert, and delete an integer X in O(1) time (i.e. , constant time, independent of the total number of integers stored). Assume that 1 ≤ X ≤ n and that there are m + n units of space available, where m is the maximum number of integers that can be in the table at any one time. (Hint: use two arrays A[1..n] and B[1..m].) You are not allowed to initialize either A or B, as that would take O(m) or O(n) operations. This means the arrays are full of random garbage to begin with, so you must be very careful. <br> [Solution link](https://research.swtch.com/sparse): <br> Two arrays both of them with garbage value <br>* dense: contains actual elements in order of insertion <br>* sparse: uses *value* of [dense] as index and stores the *index* at which the value is located <br> So the search value v is legit iff index v of sparse array points to dense's index whose value is also v</sup> |
|  [MatrixMultiplication](src/algorithmdesignmanualbook/datastructures/MatrixMultiplication.kt) <br><sub>Kotlin &#8226; datastructures</sub> | <sup></sup> |
|  [O1DataStructure](src/algorithmdesignmanualbook/datastructures/O1DataStructure.kt) <br><sub>Kotlin &#8226; datastructures</sub> | <sup>Construct a DS with search, remove and add operations of O(1) in worst case The elements are drawn from the finite set and initialization can take place at O(n)</sup> |
|  [MultiplicativeArray](src/algorithmdesignmanualbook/datastructures/MultiplicativeArray.kt) <br><sub>Kotlin &#8226; datastructures</sub> | <sup>You have an unordered array X of n integers. Find the array M containing n elements where Mi is the product of all integers in X except for Xi. You may not use division.</sup> |
|  [MiddleNodeOfLinkedList](src/algorithmdesignmanualbook/datastructures/MiddleNodeOfLinkedList.kt) <br><sub>Kotlin &#8226; datastructures</sub> | <sup>Given a singly-linked list, find its middle node. <br> Solution: Fast pointer-slow pointer approach Use two pointer, one traverses one step ahead and another by 2 steps. When the fast pointer reaches the end, the slow pointer is at middle.</sup> |
|  [BinarySearchTree](src/algorithmdesignmanualbook/datastructures/BinarySearchTree.kt) <br><sub>Kotlin &#8226; datastructures</sub> | <sup></sup> |
|  [ReverseSentence](src/algorithmdesignmanualbook/datastructures/ReverseSentence.kt) <br><sub>Kotlin &#8226; datastructures</sub> | <sup>Reverse the words in a sentence—i.e., “My name is Chris” becomes “Chris is name My.”</sup> |
|  [StringPatternMatching](src/algorithmdesignmanualbook/datastructures/StringPatternMatching.kt) <br><sub>Kotlin &#8226; datastructures</sub> | <sup>Find substring match <br> O(ab) where a = len of pattern and b = len of string</sup> |
|  [BalancedParentheses](src/algorithmdesignmanualbook/datastructures/BalancedParentheses.kt) <br><sub>Kotlin &#8226; datastructures</sub> | <sup>Check if a string contains properly nested and balanced parentheses, and false if otherwise.</sup> |
|  [FlattenBSTIntoLinkedList](src/algorithmdesignmanualbook/datastructures/FlattenBSTIntoLinkedList.kt) <br><sub>Kotlin &#8226; datastructures</sub> | <sup></sup> |
|  [ReverseLinkedList](src/algorithmdesignmanualbook/datastructures/ReverseLinkedList.kt) <br><sub>Kotlin &#8226; datastructures</sub> | <sup>[link here](https://leetcode.com/problems/reverse-linked-list)</sup> |
|  [HeapSort](src/algorithmdesignmanualbook/sorting/HeapSort.kt) <br><sub>Kotlin &#8226; sorting</sub> | <sup></sup> |
|  [MergeSort](src/algorithmdesignmanualbook/sorting/MergeSort.kt) <br><sub>Kotlin &#8226; sorting</sub> | <sup></sup> |
|  [InsertionSort](src/algorithmdesignmanualbook/sorting/InsertionSort.kt) <br><sub>Kotlin &#8226; sorting</sub> | <sup>How does insertion sort work? <br>* Loop through elements <br>* At each element, compare it with element before it <br>* If smaller, swap places <br>* Repeat</sup> |
|  [SelectionSort](src/algorithmdesignmanualbook/sorting/SelectionSort.kt) <br><sub>Kotlin &#8226; sorting</sub> | <sup>Identify the smallest element from unsorted portion and put it at the end of the sorted portion</sup> |
|  [QuickSort](src/algorithmdesignmanualbook/sorting/QuickSort.kt) <br><sub>Kotlin &#8226; sorting</sub> | <sup></sup> |
|  [PartialSumUsingFenwickTree](src/algorithmdesignmanualbook/partialsum/PartialSumUsingFenwickTree.kt) <br><sub>Kotlin &#8226; partialsum</sub> | <sup>Let A be an array of n real numbers. Design an algorithm to perform any sequence of the following operations: • Add(i,y) – Add the value y to the ith number. • Partial-sum(i) – Return the sum of the first i numbers Each operation must take O(logn). <br> Fenwick Tree or Binary Indexed Tree is a tree containing n+1 nodes. Each node's parent is right most 1 flipped i.e <br>* 8 -> 1000 so parent is 0000 (0) <br>* 7 -> 0111 so parent is 0110 (6) <br>* 10 -> 1010 so parent is 1000 (8) <br>* 5 -> 0101 so parent is 0100 (4) Sum can be obtained by (0..5) -> tree[6] + tree[4] + tree[0] i.e index+1 and then go upwards to parents <br> To get the parent: <br>* 2's complement (Flip all bits and add 1) <br>* AND it with original number <br>* Subtract it from original number <br> 7 (111) ---(step 1)---> 000+1=001 ---(AND 111)-->001 --(Subtract from 111)--->110 <br></sup> |
|  [PartialSumUsingCumulativeSum](src/algorithmdesignmanualbook/partialsum/PartialSumUsingCumulativeSum.kt) <br><sub>Kotlin &#8226; partialsum</sub> | <sup>Let A[1..n] be an array of real numbers. Design an algorithm to perform any sequence of the following operations: • Add(i,y) – Add the value y to the ith number. • Partial-sum(i) – Return the sum of the first i numbers</sup> |
|  [RecursiveMultiply](src/dynamic/RecursiveMultiply.java) <br><sub>Java &#8226; dynamic</sub> | <sup>Multiply without using *.</sup> |
|  [PermutationWithDuplicates](src/dynamic/PermutationWithDuplicates.java) <br><sub>Java &#8226; dynamic</sub> | <sup>[Video](https://www.youtube.com/watch?v=JF4QrlUJItk)</sup> |
|  [Coins](src/dynamic/Coins.java) <br><sub>Java &#8226; dynamic</sub> | <sup></sup> |
|  [EightQueens](src/dynamic/EightQueens.java) <br><sub>Java &#8226; dynamic</sub> | <sup></sup> |
|  [PaintFill](src/dynamic/PaintFill.java) <br><sub>Java &#8226; dynamic</sub> | <sup>Implement the"paint fill" function that one might see on many image editing programs. That is, given a screen (represented by a two-dimensional array of colors), a point, and a new color, fill in the surrounding area until the color changes from the original color</sup> |
|  [Parens](src/dynamic/Parens.java) <br><sub>Java &#8226; dynamic</sub> | <sup>Implement an algorithm to print all valid (i.e., properly opened and closed) combinations of n pairs of parentheses</sup> |
|  [PermutationWithoutDuplicates](src/dynamic/PermutationWithoutDuplicates.java) <br><sub>Java &#8226; dynamic</sub> | <sup></sup> |
|  [BooleanEvaluation](src/dynamic/BooleanEvaluation.java) <br><sub>Java &#8226; dynamic</sub> | <sup></sup> |
|  [TowerOfHanoi](src/dynamic/TowerOfHanoi.java) <br><sub>Java &#8226; dynamic</sub> | <sup></sup> |
|  [SortedMatrixSearch](src/sortingandsearch/SortedMatrixSearch.java) <br><sub>Java &#8226; sortingandsearch</sub> | <sup></sup> |
|  [RankFromStream](src/sortingandsearch/RankFromStream.java) <br><sub>Java &#8226; sortingandsearch</sub> | <sup>Imagine you are reading in a stream of integers. Periodically, you wish to be able to look up the rank of a number x (the number of values less than or equal to x). Implement the data structures and algorithms to support these operations. That is, implement the method track(int x), which is called when each number is generated, and the method getRankOfNumber(int x), which returns the number of values less than or equal to x (not including x itself).</sup> |
|  [SortedSearchNoSize](src/sortingandsearch/SortedSearchNoSize.java) <br><sub>Java &#8226; sortingandsearch</sub> | <sup>You are given an array-like data structure Listy which lacks a size method. It does, however, have an elementAt(i) method that returns the element at index i in 0(1) time. If i is beyond the bounds of the data structure, it returns -1. (For this reason, the data structure only supports positive integers.) Given a Listy which contains sorted, positive integers, fnd the index at which an element x occurs. If x occurs multiple times, you may return any index.</sup> |
|  [PeaksAndValley](src/sortingandsearch/PeaksAndValley.java) <br><sub>Java &#8226; sortingandsearch</sub> | <sup></sup> |
|  [GroupAnagrams](src/sortingandsearch/GroupAnagrams.java) <br><sub>Java &#8226; sortingandsearch</sub> | <sup>Write a method to sort an array ot strings so that all tne anagrams are next to each other.</sup> |
|  [SortedMerge](src/sortingandsearch/SortedMerge.java) <br><sub>Java &#8226; sortingandsearch</sub> | <sup>You are given two sorted arrays, A and B, where A has a large enough buffer at the end to hold B. Write a method to merge B into A in sorted order.</sup> |
|  [SparseSearch](src/sortingandsearch/SparseSearch.java) <br><sub>Java &#8226; sortingandsearch</sub> | <sup>Given a sorted array of strings that is interspersed with empty strings, write a method to fnd the location of a given string.</sup> |
|  [Shuffle](src/hard/Shuffle.java) <br><sub>Java &#8226; hard</sub> | <sup></sup> |
|  [AddWithoutPlus](src/hard/AddWithoutPlus.java) <br><sub>Java &#8226; hard</sub> | <sup></sup> |
|  [RandomSet](src/hard/RandomSet.java) <br><sub>Java &#8226; hard</sub> | <sup></sup> |
|  [PermutationCount](src/bigo/PermutationCount.java) <br><sub>Java &#8226; bigo</sub> | <sup></sup> |
|  [PowerOf2](src/bigo/PowerOf2.java) <br><sub>Java &#8226; bigo</sub> | <sup></sup> |
|  [PairwiseSwap](src/bits/PairwiseSwap.java) <br><sub>Java &#8226; bits</sub> | <sup>Write a program to swap odd and even bits in an integer with as few instructions as possible (e.g., bit O and bit 1 are swapped, bit 2 and bit 3 are swapped, and so on)</sup> |
|  [Conversion](src/bits/Conversion.java) <br><sub>Java &#8226; bits</sub> | <sup>Number of bits you have to flip to convert bits A to bits B</sup> |
|  [BinaryToString](src/bits/BinaryToString.java) <br><sub>Java &#8226; bits</sub> | <sup>Given a real number between 0 & 1 (eg. 0.72) that is passed in as double, print the binary representation. If # cannot be expressed in binary with at most 32 bits, then throw ERROR.</sup> |
|  [Insertion](src/bits/Insertion.java) <br><sub>Java &#8226; bits</sub> | <sup></sup> |
|  [FlipBitToWin](src/bits/FlipBitToWin.java) <br><sub>Java &#8226; bits</sub> | <sup>Find the largest sequence of 1 that can be obtained by flipping a 0 to 1.</sup> |
|  [BitUtils](src/bits/commons/BitUtils.java) <br><sub>Java &#8226; commons</sub> | <sup></sup> |
|  [FizzBuzz](src/threads/FizzBuzz.java) <br><sub>Java &#8226; threads</sub> | <sup></sup> |
|  [PickRandomNode](src/graphs/PickRandomNode.java) <br><sub>Java &#8226; graphs</sub> | <sup></sup> |
|  [CheckBST](src/graphs/CheckBST.java) <br><sub>Java &#8226; graphs</sub> | <sup>left <= current < right</sup> |
|  [ListOfDepth](src/graphs/ListOfDepth.java) <br><sub>Java &#8226; graphs</sub> | <sup>Given a binary tree, design an algorithm which creates a linked list of all the nodes at each depth (e.g., if you have a tree with depth D, you'll have D linked lists).</sup> |
|  [CheckBalanced](src/graphs/CheckBalanced.java) <br><sub>Java &#8226; graphs</sub> | <sup></sup> |
|  [PathWithSum](src/graphs/PathWithSum.java) <br><sub>Java &#8226; graphs</sub> | <sup></sup> |
|  [BuildOrder](src/graphs/BuildOrder.java) <br><sub>Java &#8226; graphs</sub> | <sup></sup> |
|  [CheckIfSubTree](src/graphs/CheckIfSubTree.java) <br><sub>Java &#8226; graphs</sub> | <sup>Check if a tree is a subtree of another</sup> |
|  [MinimalTree](src/graphs/MinimalTree.java) <br><sub>Java &#8226; graphs</sub> | <sup>Given a sorted (increasing order) array with unique integer elements, write an algorithm to create a binary search tree with minimal height.</sup> |
|  [RoutesBetweenNodes](src/graphs/RoutesBetweenNodes.java) <br><sub>Java &#8226; graphs</sub> | <sup></sup> |
|  [FirstCommonAncestor](src/graphs/FirstCommonAncestor.java) <br><sub>Java &#8226; graphs</sub> | <sup></sup> |
|  [Tree](src/graphs/commons/Tree.java) <br><sub>Java &#8226; commons</sub> | <sup></sup> |
|  [Node](src/graphs/commons/Node.java) <br><sub>Java &#8226; commons</sub> | <sup></sup> |
|  [BidirectionalTree](src/graphs/commons/BidirectionalTree.java) <br><sub>Java &#8226; commons</sub> | <sup></sup> |
|  [Graph](src/graphs/commons/Graph.java) <br><sub>Java &#8226; commons</sub> | <sup></sup> |
|  [UniqueCharacters](src/arraysandstrings/UniqueCharacters.java) <br><sub>Java &#8226; arraysandstrings</sub> | <sup></sup> |
|  [IsOneStringPermutationOfOther](src/arraysandstrings/IsOneStringPermutationOfOther.java) <br><sub>Java &#8226; arraysandstrings</sub> | <sup></sup> |
|  [StringCompression](src/arraysandstrings/StringCompression.kt) <br><sub>Kotlin &#8226; arraysandstrings</sub> | <sup></sup> |
|  [IsPermutationOfStringAPalindrome](src/arraysandstrings/IsPermutationOfStringAPalindrome.kt) <br><sub>Kotlin &#8226; arraysandstrings</sub> | <sup></sup> |
|  [OneAway](src/arraysandstrings/OneAway.kt) <br><sub>Kotlin &#8226; arraysandstrings</sub> | <sup></sup> |
|  [StringRotation](src/arraysandstrings/StringRotation.kt) <br><sub>Kotlin &#8226; arraysandstrings</sub> | <sup></sup> |
|  [MatrixRotation](src/arraysandstrings/MatrixRotation.kt) <br><sub>Kotlin &#8226; arraysandstrings</sub> | <sup></sup> |
|  [URLify](src/arraysandstrings/URLify.kt) <br><sub>Kotlin &#8226; arraysandstrings</sub> | <sup></sup> |
|  [SumLists](src/linkedlists/SumLists.kt) <br><sub>Kotlin &#8226; linkedlists</sub> | <sup></sup> |
|  [LinkedListDuplicate](src/linkedlists/LinkedListDuplicate.kt) <br><sub>Kotlin &#8226; linkedlists</sub> | <sup></sup> |
|  [LinkedList](src/linkedlists/LinkedList.kt) <br><sub>Kotlin &#8226; linkedlists</sub> | <sup></sup> |
|  [FormatPhoneNumber](src/questions/FormatPhoneNumber.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup>Given a phone number should format in the form of abc-def-ijk. Last two part can be of 2 digits</sup> |
|  [SearchContact](src/questions/SearchContact.kt) <br><sub>Kotlin &#8226; questions</sub> | <sup></sup> |
|  [baby_names](python/hard/baby_names.py) <br><sub>Python &#8226; hard</sub> | <sup></sup> |
|  [letters_and_numbers](python/hard/letters_and_numbers.py) <br><sub>Python &#8226; hard</sub> | <sup>Given an array filled with letters and numbers, fnd the longest subarray with an equal number of letters and numbers <br>:param string: string <br>:return: subarray</sup> |
|  [count_of_2s](python/hard/count_of_2s.py) <br><sub>Python &#8226; hard</sub> | <sup>Find the number of 2s in between 0 and n <br>:param number: the max value (inclusive) <br>:return: Number of 2s</sup> |
|  [langton_ant](python/moderate/langton_ant.py) <br><sub>Python &#8226; moderate</sub> | <sup>An ant is sitting on an infinite grid of white and black squares. It initially faces right. At each step, it does the following: (1) At a white square, flip the color of the square, turn 90 degrees right (clockwise), and move forward one unit. (2) At a black square, flip the color of the square, turn 90 degrees left (counter-clockwise), and move forward one unit. Write a program to simulate the first K moves that the ant makes and print the final board as a grid.</sup> |
|  [calculator](python/moderate/calculator.py) <br><sub>Python &#8226; moderate</sub> | <sup></sup> |
|  [pairs_with_sum](python/moderate/pairs_with_sum.py) <br><sub>Python &#8226; moderate</sub> | <sup></sup> |
|  [pond_sizes](python/moderate/pond_sizes.py) <br><sub>Python &#8226; moderate</sub> | <sup>You have an integer matrix representing a plot of land, where the value at that location represents the height above sea level. A value of zero indicates water. A pond is a region of water connected vertically, horizontally, or diagonally. The size of the pond is the total number of connected water cells. Write a method to compute the sizes of all ponds in the matrix</sup> |
|  [swap_sum](python/moderate/swap_sum.py) <br><sub>Python &#8226; moderate</sub> | <sup></sup> |
|  [pattern_matching](python/moderate/pattern_matching.py) <br><sub>Python &#8226; moderate</sub> | <sup>You are given two strings, pattern and value. The pattern string consists of just the letters a and b, describing a pattern within a string. For example, the string catcatgocatgo matches the pattern aabab (where cat is a and go is b). It also matches patterns like a, ab, and b. Write a method to determine if value matches pattern.</sup> |
|  [continuous_sequence](python/moderate/continuous_sequence.py) <br><sub>Python &#8226; moderate</sub> | <sup></sup> |
|  [master_mind](python/moderate/master_mind.py) <br><sub>Python &#8226; moderate</sub> | <sup></sup> |
|  [sub_sort](python/moderate/sub_sort.py) <br><sub>Python &#8226; moderate</sub> | <sup></sup> |
|  [bisect_squares](python/moderate/bisect_squares.py) <br><sub>Python &#8226; moderate</sub> | <sup></sup> |
|  [diving_board](python/moderate/diving_board.py) <br><sub>Python &#8226; moderate</sub> | <sup>Arranging k planks end-to-end means that arranging (k short, 0 long), (k-1 short, 1 long), (k-2 short, 2 long)... <br>:param k: the number of planks <br>:return: the all possible length of arrangements</sup> |
|  [xml_encoding](python/moderate/xml_encoding.py) <br><sub>Python &#8226; moderate</sub> | <sup></sup> |
|  [count_pairs_with_difference](python/moderate/count_pairs_with_difference.py) <br><sub>Python &#8226; moderate</sub> | <sup></sup> |
|  [operation](python/moderate/operation.py) <br><sub>Python &#8226; moderate</sub> | <sup></sup> |
|  [living_people](python/moderate/living_people.py) <br><sub>Python &#8226; moderate</sub> | <sup></sup> |
|  [factorial_zeros](python/moderate/factorial_zeros.py) <br><sub>Python &#8226; moderate</sub> | <sup></sup> |
|  [smallest_difference](python/moderate/smallest_difference.py) <br><sub>Python &#8226; moderate</sub> | <sup></sup> |
|  [english_int](python/moderate/english_int.py) <br><sub>Python &#8226; moderate</sub> | <sup></sup> |
|  [tic_tac](python/moderate/tic_tac.py) <br><sub>Python &#8226; moderate</sub> | <sup></sup> |
|  [intersection](python/moderate/intersection.py) <br><sub>Python &#8226; moderate</sub> | <sup></sup> |
|  [needle](python/needle.py) <br><sub>Python &#8226; python</sub> | <sup></sup> |
|  [reverseint](python/reverseint.py) <br><sub>Python &#8226; python</sub> | <sup></sup> |
|  [three_sums](python/three_sums.py) <br><sub>Python &#8226; python</sub> | <sup></sup> |
|  [multiply](python/multiply.py) <br><sub>Python &#8226; python</sub> | <sup></sup> |
|  [paritysort](python/paritysort.py) <br><sub>Python &#8226; python</sub> | <sup></sup> |
|  [remove_element](python/remove_element.py) <br><sub>Python &#8226; python</sub> | <sup></sup> |
|  [longestsubstr](python/longestsubstr.py) <br><sub>Python &#8226; python</sub> | <sup></sup> |
|  [addTwoNumbers](python/addTwoNumbers.py) <br><sub>Python &#8226; python</sub> | <sup></sup> |
|  [sumEvenAfterQueries](python/sumEvenAfterQueries.py) <br><sub>Python &#8226; python</sub> | <sup></sup> |
|  [valid_paranthesis](python/valid_paranthesis.py) <br><sub>Python &#8226; python</sub> | <sup></sup> |
|  [stack_of_plates](python/stacksqueues/stack_of_plates.py) <br><sub>Python &#8226; stacksqueues</sub> | <sup></sup> |
|  [stack](python/stacksqueues/stack.py) <br><sub>Python &#8226; stacksqueues</sub> | <sup></sup> |
|  [animal_shelter](python/stacksqueues/animal_shelter.py) <br><sub>Python &#8226; stacksqueues</sub> | <sup></sup> |
|  [queueviastacks](python/stacksqueues/queueviastacks.py) <br><sub>Python &#8226; stacksqueues</sub> | <sup></sup> |
|  [stack_min](python/stacksqueues/stack_min.py) <br><sub>Python &#8226; stacksqueues</sub> | <sup></sup> |
|  [sort_stack](python/stacksqueues/sort_stack.py) <br><sub>Python &#8226; stacksqueues</sub> | <sup></sup> |
|  [string_compression](python/codinginterview/string_compression.py) <br><sub>Python &#8226; codinginterview</sub> | <sup></sup> |
|  [delete_middle](python/codinginterview/delete_middle.py) <br><sub>Python &#8226; codinginterview</sub> | <sup>Delete kth node from linked list <br> Parameters: linked_ (LinkedList): a Linked List k (int): the kth position <br></sup> |
|  [quick_sort](python/codinginterview/quick_sort.py) <br><sub>Python &#8226; codinginterview</sub> | <sup></sup> |
|  [merge_sort](python/codinginterview/merge_sort.py) <br><sub>Python &#8226; codinginterview</sub> | <sup></sup> |
|  [zero_matrix](python/codinginterview/zero_matrix.py) <br><sub>Python &#8226; codinginterview</sub> | <sup>Make INPLACE row and column of a matrix 0 iff that row contains a 0</sup> |
|  [string_rotation](python/codinginterview/string_rotation.py) <br><sub>Python &#8226; codinginterview</sub> | <sup>Check if one string is formed by rotating the other string eg: abcd, dabc, cdab, bcda</sup> |
|  [delete_duplicates](python/codinginterview/delete_duplicates.py) <br><sub>Python &#8226; codinginterview</sub> | <sup>Delete duplicate node from a Linked List <br> Parameters: linked_list: The list to be deleted from</sup> |
|  [kth_to_last](python/codinginterview/kth_to_last.py) <br><sub>Python &#8226; codinginterview</sub> | <sup>Get all nodes from kth position to the end</sup> |
|  [matrix_rotation](python/codinginterview/matrix_rotation.py) <br><sub>Python &#8226; codinginterview</sub> | <sup></sup> |
|  [linked_list](python/codinginterview/shared/linked_list.py) <br><sub>Python &#8226; shared</sub> | <sup></sup> |
|  [base_linked_list](python/codinginterview/shared/base_linked_list.py) <br><sub>Python &#8226; shared</sub> | <sup></sup> |
|  [reversed_linked_list](python/codinginterview/shared/reversed_linked_list.py) <br><sub>Python &#8226; shared</sub> | <sup></sup> |
|  [circular_linked_list](python/codinginterview/shared/circular_linked_list.py) <br><sub>Python &#8226; shared</sub> | <sup></sup> |
|  [node](python/codinginterview/shared/node.py) <br><sub>Python &#8226; shared</sub> | <sup></sup> |

___
<sub>This README was auto-generated during pre-commit.</sub>
 
##### IntelliJ Live Template
```
import _utils.UseCommentAsDocumentation

/**
 * $END$
 * [Source](https://leetcode.com/problems/$camelCase$/)
*/
@UseCommentAsDocumentation
private fun solution() {
}
    
fun main() {
}
```
where `camelCase`=`lowercaseAndDash(fileName())`
